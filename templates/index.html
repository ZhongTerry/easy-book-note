<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart NoteDB</title>
    <!-- 引入 PureUI 样式和脚本 -->
    <link rel="stylesheet" href="/purecss/pure2.1.css">
    <script src="/purecss/pure2.1.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <!-- 标准 Favicon -->
<link rel="icon" href="/static/icons/favicon.ico" type="image/x-icon">
<link rel="icon" type="image/png" sizes="32x32" href="/static/icons/icon-32.png">

<!-- iOS Apple Touch Icon -->
<link rel="apple-touch-icon" href="/static/icons/apple-touch-icon.png">

<!-- 确保引入了 manifest -->
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#4f46e5">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="NoteDB">


<!-- 注册 Service Worker -->
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js');
    });
  }
</script>
    <!-- <meta name="color-scheme" content="light"> -->
    <style>
        /* === 布局修正 (颜色交给 pure2.1.css 管理) === */
        /* --- 按钮行移动端优化 --- */
/* === 📱 手机端列表卡片化重构 (修复重叠) === */
        /* 顶部用户栏 */
        #userBar {
            background: rgba(255,255,255,0.9); /* 保持半透明白 */
            padding: 10px 20px; 
            border-bottom: 1px solid #eee; 
            display: flex; justify-content: space-between; align-items: center; 
            font-size: 14px;
        }

        /* 主容器：只负责位置和宽窄，颜色交给 p-card */
        /* 在 index.html 的 <style> 标签里 */

.container {
    max-width: 850px; 
    margin: 40px auto; /* 增加一点顶部距离，更好看 */
    
    /* 👇👇👇 核心修复：把白框框加回来！👇👇👇 */
    background-color: #ffffff; /* 强制纯白背景 */
    padding: 40px;             /* 宽敞的内边距 */
    border-radius: 16px;       /* 圆润的边角 */
    
    /* 加一个更有质感的阴影，让它“浮”起来 */
    box-shadow: 0 10px 40px -10px rgba(0,0,0,0.08);
    
    /* 加一个极细的边框，增强边界感 */
    border: 1px solid #f1f5f9;
}

        h1 { margin-top: 0; color: #1f2937; text-align: center; font-size: 26px; margin-bottom: 25px;}

        /* 输入组布局 */
        .input-group { margin-bottom: 15px; }
        .input-label { display: block; margin-bottom: 6px; font-weight: 600; color: #4b5563; font-size: 13px;}

        /* 按钮行布局 */
        .btn-row { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 25px; }
        
        /* 仅保留布局属性，不覆盖 PureUI 的样式 */
        .btn-row .p-btn { 
            flex: 1;                /* 保持平分宽度 */
            min-width: fit-content; /* 防止挤压 */
        }

        /* 结果区域 */
        .output { margin-top: 25px; border-top: 1px solid #eee; padding-top: 20px; }
        
        /* 消息框 (保留，因为这是 JS 动态控制的) */
        #msgBox { 
            padding: 10px; border-radius: 6px; margin-bottom: 15px; font-size: 14px; display: none; 
            text-align: center;
        }
        #msgBox.success { background: #d1fae5; color: #065f46; border: 1px solid #a7f3d0; }
        #msgBox.error { background: #fee2e2; color: #991b1b; border: 1px solid #fecaca; }

        /* 表格微调 */
        table { width: 100%; border-collapse: collapse; font-size: 14px; }
        th { text-align: left; padding: 10px; background: #f9fafb; color: #6b7280; }
        td { padding: 12px 5px; border-bottom: 1px solid #eee; vertical-align: middle; }
        
        .key-final { font-weight: bold; color: #1f2937; font-size: 15px;}
        
        /* 辅助类 */
        .action-group { display: flex; gap: 5px; justify-content: flex-end; align-items: center; }
        
        /* 标签栏滚动容器 */
        .filter-bar {
            display: flex; gap: 8px; overflow-x: auto; padding: 5px 0 15px 0;
            scrollbar-width: none;
        }
        
        /* 书架网格微调 */
        .bookshelf-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 20px; padding: 10px 0; }
        .book-card { 
            background: white; border-radius: 8px; overflow: hidden; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
            transition: transform 0.2s; cursor: pointer; 
            display: flex; flex-direction: column; aspect-ratio: 2 / 3; border: 1px solid #eee; 
        }
        .book-card:hover { transform: translateY(-5px); border-color: #4f46e5; }
        .book-cover { flex: 1; padding: 15px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; color: white; background: linear-gradient(135deg, #667eea, #764ba2); position: relative; }
        .book-title-card { font-size: 16px; font-weight: bold; text-shadow: 0 1px 2px rgba(0,0,0,0.2); overflow: hidden; }
        .book-info-row { padding: 8px; background: white; display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: #666; border-top: 1px solid #f0f0f0; }

        /* 拖拽上传样式 */
        #value.drag-over { border-color: #10b981 !important; box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2); }
        /* --- 移动端适配补丁 --- */

/* 1. 统一操作栏布局 */
.action-group {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 8px; /* 增加间距感 */
}

/* 2. 分割线样式 */
.v-line {
    border-left: 1px solid #e5e7eb;
    height: 16px;
    margin: 0 2px;
}

/* 3. 核心：移动端自动隐藏按钮文字 */

/* 强制对齐：确保链接 A 标签和 Button 标签高度一致 */
.action-group a.p-btn, 
.action-group button.p-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    height: 32px; /* 固定高度防止错位 */
    box-sizing: border-box;
    vertical-align: middle;
}
        /* 洞察页面 Grid */
        .stats-grid-4 { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }
        .stat-card { background: #f9fafb; padding: 15px; border-radius: 8px; text-align: center; border: 1px solid #e5e7eb; }
        .stat-num { font-size: 24px; font-weight: bold; color: #4f46e5; }
        .heatmap-grid { display: flex; gap: 2px; height: 60px; align-items: flex-end; margin-top: 10px; }
        .heat-bar { flex: 1; background: #e5e7eb; border-radius: 2px; transition: height 0.5s; min-height: 2px; }
        /* === 书签操作栏样式 === */

/* 1. 电脑端默认：一行靠右排列 */
.action-group {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 4px;
    height: 32px; /* 强制高度，防止抖动 */
}

/* 垂直分割线 */
.v-line {
    border-left: 1px solid #e5e7eb;
    height: 14px;
    margin: 0 4px;
}

/* 按钮通用微调 */
.action-group .p-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    height: 30px;
    white-space: nowrap;
}

/* === 2. 手机端强制优化 (宽度 <= 600px) === */
/* === 📱 手机端强制重构 (修复重叠与乱序) === */
/* === 统一按钮样式 === */
.action-group {
    display: flex;
    gap: 6px;
    justify-content: flex-end;
    align-items: center;
}

/* 阅读按钮基础样式 */
.read-btn {
    display: flex; 
    align-items: center; 
    gap: 4px;
    transition: all 0.2s;
}

/* 小图标按钮 (更新、书单、更多) */
.icon-btn {
    padding: 0 !important;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
}

/* 更多菜单项样式 */
.action-item {
    padding: 15px 20px;
    border-bottom: 1px solid #f5f5f5;
    cursor: pointer;
    font-size: 15px;
    color: #333;
    transition: background 0.1s;
}
.action-item:hover { background: #f9fafb; }
.action-item:active { background: #f0f0f0; }
.action-item.danger { color: #ef4444; font-weight: bold; border-bottom: none; }

/* === 💻 PC端特有样式 (宽度 > 600px) === */
@media (min-width: 601px) {
    /* 更多菜单：居中弹窗 */
    .more-menu-content {
        width: 300px;
        border-radius: 12px;
    }
}

/* === 📱 手机端适配 (宽度 <= 600px) === */

/* --- 更新日志相关样式 --- */
.changelog-link-wrap {
    text-align: center;
    margin: 40px 0 20px;
}

.btn-changelog {
    font-size: 12px;
    color: var(--text-meta);
    text-decoration: none;
    cursor: pointer;
    transition: color 0.2s;
}

.btn-changelog:hover {
    color: var(--accent);
}

/* 日志文本容器：保持原始排版 */
#changelogContent {
    font-size: 14px;
    line-height: 1.6;
    color: var(--text-main);
    white-space: pre-wrap; /* 关键：保留 .log 文件的换行和空格 */
    background: #f8f9fa;
    padding: 15px;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    max-height: 400px;
    overflow-y: auto;
}

body.dark-mode #changelogContent {
    background: #1a1a1a;
}
/* --- 彻底修复：日志弹窗渲染重置 --- */
#changelogContent {
    white-space: normal !important; /* 强制关闭 pre-wrap */
    text-align: left !important;
    max-height: 60vh;
    overflow-y: auto;
    padding: 10px;
    display: block !important; /* 确保容器是块级，不是 flex */
}

/* 每一个版本的大盒子 */
.version-block {
    display: block !important; /* 确保不受外层 flex 影响 */
    padding: 20px !important;
    margin-bottom: 20px !important;
    border-radius: 12px !important;
    border: 1px solid #e2e8f0 !important;
    background: #ffffff !important;
    box-shadow: 0 2px 5px rgba(0,0,0,0.02) !important;
    position: relative;
    color: #1a202c !important;
}

/* 高亮当前版本：去除那种奇怪的蓝色块 */
.version-block.active-ver {
    border: 2px solid #4f46e5 !important;
    background: #f8faff !important; /* 极浅的蓝底 */
}

/* “当前版本”的小标签 */
.version-tag {
    display: inline-block !important;
    background: #4f46e5 !important;
    color: #ffffff !important;
    font-size: 11px !important;
    padding: 2px 10px !important;
    border-radius: 50px !important;
    margin-bottom: 12px !important;
    font-weight: bold !important;
}

/* 标题样式：防止背景溢出 */
.version-title {
    display: block !important;
    font-size: 1.2rem !important;
    font-weight: 700 !important;
    margin: 0 0 15px 0 !important;
    padding: 0 !important;
    color: #111827 !important;
    background: transparent !important; /* 彻底移除可能的背景色 */
    border: none !important;
}

/* 列表样式重置 */
.version-content ul {
    list-style-type: disc !important;
    margin: 0 !important;
    padding-left: 25px !important;
}

.version-content li {
    margin-bottom: 10px !important;
    font-size: 14px !important;
    line-height: 1.6 !important;
    background: transparent !important; /* 核心：防止出现截图中的蓝色条 */
    color: #4a5568 !important;
    display: list-item !important; /* 强制表现为列表项 */
}

.version-content strong {
    color: #4f46e5 !important;
}

/* 黑暗模式适配 */
body.dark-mode .version-block {
    background: #1e1e1e !important;
    border-color: #333 !important;
    color: #cecece !important;
}
body.dark-mode .version-block.active-ver {
    background: #1a1c2e !important;
}
body.dark-mode .version-title { color: #f3f4f6 !important; }
body.dark-mode .version-content li { color: #a0aec0 !important; }
/* === 搜索模态框优化 === */

/* 1. 让弹窗变宽 */
#searchModal .p-modal-content {
    max-width: 800px !important; /* 宽度加倍 */
    width: 90%;                  /* 移动端适配 */
    height: 80vh;                /*以此固定高度，防止内容少时太短 */
    display: flex;
    flex-direction: column;
}

/* 2. 搜索结果容器：允许滚动 */
.search-results {
    flex: 1;                     /* 占满剩余空间 */
    overflow-y: auto;            /* 内部滚动 */
    padding: 10px;
    background: #f9fafb;         /* 浅灰底色 */
    border-radius: 8px;
    margin-top: 15px;
    border: 1px solid #eee;
}

/* 3. 搜索结果单项：卡片式设计 */
.result-item {
    background: white;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 10px;
    border: 1px solid #e5e7eb;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    justify-content: space-between; /* 左右布局 */
    align-items: center;
}

.result-item:hover {
    border-color: #4f46e5;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.05);
}

/* 左侧信息区 */
.res-left {
    flex: 1;
    min-width: 0; /* 防止文本溢出撑开 */
}

.res-title {
    font-size: 16px;
    font-weight: 700;
    color: #1f2937;
    margin-bottom: 6px;
}

.res-meta {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 12px;
    color: #6b7280;
}

/* 来源标签 */
.source-tag {
    padding: 2px 8px;
    border-radius: 4px;
    font-weight: bold;
    font-size: 11px;
}
/* 不同源不同色 */
.tag-360 { background: #dcfce7; color: #166534; }   /* 绿色 */
.tag-baidu { background: #dbeafe; color: #1e40af; } /* 蓝色 */
.tag-bing { background: #fef3c7; color: #92400e; }  /* 黄色 */
.tag-direct { background: #fce7f3; color: #9d174d; }/* 粉色 */

.res-url {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 300px;
}

/* 右侧动作图标 */
.res-action {
    color: #4f46e5;
    font-weight: bold;
    font-size: 14px;
    padding-left: 15px;
}

/* 黑暗模式适配 */
@media (prefers-color-scheme: dark) { /* 或者你的 body.dark-mode */
    .search-results { background: #1a1a1a; border-color:#333; }
    .result-item { background: #262626; border-color:#333; }
    .res-title { color: #e5e7eb; }
    .res-meta { color: #9ca3af; }
}
/* === 搜索结果 - 亮色模式精修 (Light Mode) === */

/* 1. 列表容器：清爽的灰白底色，衬托卡片 */
.search-results {
    background-color: #f3f4f6 !important; /* 极浅的冷灰色 */
    border: 1px solid #e5e7eb !important;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.02); /* 内部微阴影，增加深度 */
}

/* 2. 单个结果卡片：纯白、圆润、轻盈 */
.result-item {
    background-color: #ffffff !important;
    border: 1px solid #ffffff !important; /* 默认白边框，更干净 */
    box-shadow: 0 2px 5px rgba(0,0,0,0.03) !important; /* 极轻的悬浮阴影 */
    margin-bottom: 12px !important;
}

/* 3. 鼠标悬浮：卡片上浮，投影加深，边框亮起 */
.result-item:hover {
    background-color: #ffffff !important;
    border-color: #6366f1 !important; /* 亮紫色边框 */
    box-shadow: 0 8px 20px rgba(99, 102, 241, 0.15) !important; /* 紫色调的柔和光晕 */
    transform: translateY(-2px);
}

/* 4. 文字排版优化 */
.res-title {
    color: #111827 !important; /* 接近纯黑，高对比度 */
    font-size: 17px !important;
    letter-spacing: -0.01em;
}

.res-url {
    color: #9ca3af !important; /* 浅灰，不抢视觉 */
    font-family: monospace;    /* 网址用等宽字体更有科技感 */
    background: #f9fafb;
    padding: 2px 6px;
    border-radius: 4px;
}

/* 5. 右侧“解析阅读”按钮美化 */
.res-action {
    color: #4f46e5 !important;
    background: #eef2ff !important; /* 淡紫色胶囊背景 */
    padding: 6px 14px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 600;
    transition: all 0.2s;
}

.result-item:hover .res-action {
    background: #4f46e5 !important; /* 悬浮时变实心紫 */
    color: #ffffff !important;
}

/* 6. 标签配色微调 (更鲜艳一点) */
.tag-360 { background: #d1fae5; color: #065f46; border: 1px solid #a7f3d0; }
.tag-baidu { background: #dbeafe; color: #1e40af; border: 1px solid #bfdbfe; }
.tag-direct { background: #fce7f3; color: #9d174d; border: 1px solid #fbcfe8; }
/* 新增：作者信息样式 */
.res-author {
    font-size: 12px;
    color: #4b5563;            /* 深灰色文字，不是纯白 */
    background-color: #f3f4f6; /* 极浅的灰色背景 */
    padding: 2px 8px;
    border-radius: 4px;
    margin-left: 8px;
    font-weight: 500;
    border: 1px solid #e5e7eb; /* 增加一个微弱的边框，更有质感 */
}

/* 2. 黑暗模式适配：深色底 */
@media (prefers-color-scheme: dark), body.dark-mode {
    .res-author {
        color: #d1d5db;        /* 亮灰文字 */
        background-color: #374151; /* 深灰背景 */
        border-color: #4b5563;
    }
}
/* === 新版热力图 (ECharts) === */
.heatmap-container {
    width: 100%;
    height: 140px;
    margin-top: 10px;
    position: relative;
}

#heatmapChart {
    width: 100%;
    height: 100%;
}
/* === 统一按钮样式 === */
.action-group {
    display: flex;
    gap: 6px;
    justify-content: flex-end;
    align-items: center;
}

/* 阅读按钮基础样式 */
.read-btn {
    display: flex; 
    align-items: center; 
    gap: 4px;
    transition: all 0.2s;
}

/* 小图标按钮 (更新、书单、更多) */
.icon-btn {
    padding: 0 !important;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
}

/* 更多菜单项样式 */
.action-item {
    padding: 15px 20px;
    border-bottom: 1px solid #f5f5f5;
    cursor: pointer;
    font-size: 15px;
    color: #333;
    transition: background 0.1s;
}
.action-item:hover { background: #f9fafb; }
.action-item:active { background: #f0f0f0; }
.action-item.danger { color: #ef4444; font-weight: bold; border-bottom: none; }

/* === 💻 PC端特有样式 (宽度 > 600px) === */
@media (min-width: 601px) {
    /* 更多菜单：居中弹窗 */
    .more-menu-content {
        width: 300px;
        border-radius: 12px;
    }
}

/* === 📱 手机端适配 (宽度 <= 600px) === */
/* === 📱 手机端 UI 优化 (Flex 布局修复) === */
@media (max-width: 600px) {
    /* 1. 按钮容器：改为弹性布局 */
    .action-group {
        display: flex !important;
        gap: 8px !important; /* 按钮之间的间距 */
        width: 100% !important;
        justify-content: flex-end; /* 靠右对齐 (如果没有阅读按钮时) */
    }

    /* 2. 通用图标按钮 (方形) */
    .action-group .p-btn {
        width: 42px !important;      /* 固定宽度 */
        height: 42px !important;     /* 固定高度 */
        padding: 0 !important;       /* 移除内边距，确保居中 */
        flex: none !important;       /* 禁止拉伸 */
        display: flex !important;
        align-items: center;
        justify-content: center;
        border-radius: 8px !important;
        background-color: #f3f4f6;   /* 浅灰背景 */
        border: 1px solid #e5e7eb;
        color: #374151;
    }

    /* 3. 阅读按钮 (C位，自动拉伸) */
    .action-group .p-btn-primary {
        flex: 1 !important;          /* 占据剩余空间 */
        width: auto !important;
        background-color: #4f46e5 !important;
        color: white !important;
        border: none !important;
        
        /* === 核心布局修复 === */
        display: flex !important;
        align-items: center !important;     /* 垂直居中 */
        justify-content: center !important; /* 水平居中 */
        gap: 6px !important;                /* 图标和文字的间距 */
        height: 42px !important;            /* 固定高度，和其他按钮一致 */
        padding: 0 8px !important;          /* 防止文字贴边 */
        overflow: hidden !important;        /* 防止溢出 */
    }
    
    /* 修复文字样式 */
    .action-group .p-btn-primary .btn-text {
        font-size: 15px !important;    /* 稍微调小一点，太大会撑开 */
        font-weight: bold !important;
        line-height: 1 !important;     /* 消除行高带来的垂直偏移 */
        white-space: nowrap !important; /* 禁止换行 */
        display: inline-block !important;
        margin-top: 1px;               /* 视觉微调，让文字视觉居中 */
    }

    /* 修复图标样式 */
    .action-group .p-btn-primary span:first-child {
        font-size: 18px !important;
        line-height: 1 !important;
        display: flex !important;      /* 消除 baseline 对齐问题 */
    }
}
.book-list-container {
    display: flex; flex-direction: column; gap: 15px; margin-top: 20px;
}

.book-row {
    display: flex;
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 15px;
    position: relative;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    transition: all 0.2s;
}
.book-row:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 12px rgba(0,0,0,0.05);
    border-color: #d1d5db;
}

/* 封面 */
.book-cover-img {
    width: 80px; height: 106px; object-fit: cover;
    border-radius: 4px; background: #f3f4f6; flex-shrink: 0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.book-cover-default {
    width: 80px; height: 106px; border-radius: 4px;
    background: linear-gradient(135deg, #e0e7ff 0%, #f3f4f6 100%);
    display: flex; align-items: center; justify-content: center;
    color: #6366f1; font-weight: bold; font-size: 24px; flex-shrink: 0;
}

/* 信息区 */
.book-info {
    flex: 1; margin-left: 15px; margin-right: 10px;
    display: flex; flex-direction: column; justify-content: space-between;
}
.book-header { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
.book-title { font-size: 17px; font-weight: 700; color: #1f2937; }
.tag-badge { font-size: 11px; background: #f3f4f6; color: #6b7280; padding: 2px 6px; border-radius: 4px; }

.book-meta { font-size: 13px; color: #6b7280; display: flex; align-items: center; gap: 12px; margin-bottom: 6px; }
.book-desc {
    font-size: 13px; color: #9ca3af; line-height: 1.4;
    display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
    overflow: hidden; margin-bottom: 8px;
}

/* 桌面端操作栏 (垂直排列) */
.action-col {
    display: flex; flex-direction: column; justify-content: center; gap: 8px;
    min-width: 90px; border-left: 1px solid #f3f4f6; padding-left: 15px;
}

/* 通用动作按钮 */
.act-btn {
    display: inline-flex; align-items: center; justify-content: center; gap: 6px;
    padding: 6px 12px; border-radius: 6px; font-size: 13px; font-weight: 600;
    cursor: pointer; transition: 0.2s; text-decoration: none;
}
.act-primary { background: #4f46e5; color: white; border: 1px solid #4f46e5; }
.act-primary:hover { background: #4338ca; }

/* 次级按钮样式 (更新 & 更多) */
.act-outline {
    background: white; color: #374151; border: 1px solid #e5e7eb;
}
.act-outline:hover {
    border-color: #4f46e5; color: #4f46e5; background: #eff6ff;
}
@media (max-width: 600px) {
    .book-row { padding-bottom: 50px; } /* 底部留给按钮 */
    .book-cover-img, .book-cover-default { width: 70px; height: 93px; }
    .book-title { font-size: 16px; }
    .book-desc { display: none; } /* 隐藏简介 */
    
    .action-col {
        border-left: none; padding-left: 0;
        flex-direction: row; /* 变横排 */
        position: absolute; bottom: 12px; right: 15px; left: 100px;
        justify-content: flex-end;
    }
    .act-btn { padding: 4px 10px; font-size: 12px; }
}
    </style>
        <script>
            // === [核心修复] 智能关闭 Modal ===
        // 只有当点击事件真正发生在遮罩层本身(overlay)时才关闭
        // 解决了“在内部选中文字拖拽到外部松开导致关闭”的 Bug
        function closeByOverlay(event, modalId) {
            if (event.target === event.currentTarget) {
                document.getElementById(modalId).style.display = 'none';
            }
        }
        </script>
</head>
<body>

    <!-- 用户栏 -->
    <!-- index.html -->
    <div id="userBar">
        <div style="display: flex; align-items: center; gap: 10px;">
            <img id="userAvatar" src="" width="32" style="border-radius: 50%; background: #eee;">
            <div>
                <span id="userName" style="font-weight: 600; display:block; line-height:1.2;">Loading...</span>
                <!-- 新增：显示角色标签 -->
                <span id="userRoleBadge" class="p-tag" style="font-size:10px; padding:0 4px; display:none;">User</span>
            </div>
        </div>
        
        <div style="display: flex; gap: 10px; align-items: center;">
            <button id="desktopSettingsBtn" class="p-btn p-btn-sm" style="display:none; background:#4f46e5; color:white;" onclick="openDesktopSettings()">
                🖥️ 客户端设置
            </button>
            <!-- 新增：管理面板入口 (默认隐藏) -->
            <a href="/admin" id="adminEntryBtn" class="p-btn p-btn-sm" style="display:none; background:#374151; color:white; text-decoration:none;">🔧 管理后台</a>
            
            <a href="/logout" class="p-btn p-btn-sm p-btn-danger" style="text-decoration: none;">🚪 登出</a>
        </div>
        
    </div>

    <div class="container">
        <h1>⚡ Smart NoteDB</h1>
        
        <!-- 输入区域：使用 PureUI p-input -->
        <div class="input-group">
            <label class="input-label">Key (拼音缩写 / 分类)</label>
            <input type="text" id="key" class="p-input" placeholder="例如: frxxz (凡人修仙传)" onkeydown="handleEnter(event)">
        </div>
        
        <div class="input-group">
            <label class="input-label">Value (链接 / 拖入EPUB)</label>
            <input type="text" id="value" class="p-input" placeholder="https://... 或将 .epub 拖入此处" onkeydown="handleEnter(event)">
        </div>

        <!-- 按钮行：使用 PureUI p-btn -->
        <div class="btn-row">
            <button class="p-btn p-btn-primary" onclick="doAction('insert')">💾 保存</button>
            <button class="p-btn p-btn-primary" style="background:#0ea5e9; border-color:#0ea5e9;" onclick="doAction('find')">🔍 查库</button>
            
            <button class="p-btn p-btn-outline" onclick="window.open('/search', '_blank')">🌐 搜书</button>
            
            <!-- <button class="p-btn p-btn-outline" onclick="doAction('list')">📜 书架</button> -->
            <button class="p-btn p-btn-outline" onclick="openHistory()">⏳ 历史</button>
            <button class="p-btn p-btn-outline" onclick="openExportHistory()">📦 导出</button>
            <button class="p-btn p-btn-outline" style="color: #10b981; border-color: #10b981;" onclick="openDownloadsManager()">💾 下载</button>
            <!-- <button class="p-btn p-btn-outline" style="color: #f59e0b; border-color: #f59e0b;" onclick="doRollback()">⏪ 撤销</button> -->
            <button class="p-btn p-btn-outline" onclick="openBooklists()">📚 书单</button>
            <button class="p-btn" style="background: linear-gradient(45deg, #11998e, #38ef7d); color: white; border:none;" onclick="openInsight()">📊 洞察</button>
            
            <!-- <button class="p-btn p-btn-danger" onclick="confirmDelete()">🗑️ 删除</button> -->
        </div>

        <div class="output">
            <!-- 标签栏 -->
            <div class="filter-bar" id="filterBar">
                <span class="p-tag filter-chip active" onclick="filterByTag('all')">全部</span>
            </div>

            <!-- 视图切换 (保留简单文本按钮，或者用 p-btn-sm) -->
            <div id="viewToggleBar" style="text-align: right; margin-bottom: 10px;">
                <button class="p-btn p-btn-sm toggle-btn active" onclick="switchView('list')">☰ 列表</button>
                <button class="p-btn p-btn-sm toggle-btn" onclick="switchView('grid')">☷ 网格</button>
            </div>

            <div id="msgBox"></div>
            <div id="tableContainer"></div>
        </div>
    </div>
    <!-- 在 .main-container 闭合标签之前 -->
    <div class="changelog-link-wrap">
        <a class="btn-changelog" onclick="showChangelog(false)">📑 版本更新日志 (ChangeLog)</a>
    </div>
</div> <!-- .main-container 结束 -->
    <!-- === 模态框: 搜索 (使用 PureUI Modal 结构) === -->
    <div id="searchModal" class="p-modal" onclick="closeByOverlay(event, 'settingsModal')">
        <div class="p-modal-content">
            <div style="display:flex; justify-content:space-between; margin-bottom:15px;">
                <h3 style="margin:0">全网搜书</h3>
                <!-- <button class="p-btn p-btn-sm" onclick="PureUI.modal.close('searchModal')">✕</button> -->
            </div>
            <div style="display:flex; gap:10px; margin-bottom:10px;">
                <input type="text" id="onlineSearchInput" class="p-input" placeholder="输入书名..." onkeydown="if(event.key==='Enter') doOnlineSearch()">
                <button class="p-btn p-btn-primary" onclick="doOnlineSearch()">搜索</button>
            </div>
            <div id="searchResults" class="search-results">
                <div style="padding:10px; text-align:center; color:#999;">请输入书名...</div>
            </div>
        </div>
    </div>

    <!-- === 模态框: 洞察 (Tab页) === -->
    <div id="insightModal" class="p-modal" onclick="closeByOverlay(event, 'settingsModal')">
        <div class="p-modal-content" style="max-width: 600px;">
            <div style="display:flex; justify-content:space-between; margin-bottom:15px;">
                <h3 style="margin:0">📊 阅读洞察</h3>
                <!-- <button class="p-btn p-btn-sm" onclick="PureUI.modal.close('insightModal')">✕</button> -->
            </div>
            
            <!-- Tabs -->
            <div style="display:flex; justify-content:center; gap:10px; margin-bottom:20px;">
                <button class="p-tag insight-tab active" onclick="switchInsightTab('24h', this)" style="cursor:pointer; border:1px solid #eee;">今日</button>
                <button class="p-tag insight-tab" onclick="switchInsightTab('7d', this)" style="cursor:pointer; border:1px solid #eee;">7天</button>
                <button class="p-tag insight-tab" onclick="switchInsightTab('all', this)" style="cursor:pointer; border:1px solid #eee;">全部</button>
            </div>

            <!-- 数据展示 -->
            <div class="stats-grid-4">
                <div class="stat-card"><div class="stat-num" id="s-time">0</div><div style="font-size:12px; color:#888">时长(分)</div></div>
                <div class="stat-card"><div class="stat-num" id="s-words">0</div><div style="font-size:12px; color:#888">字数</div></div>
                <div class="stat-card"><div class="stat-num" id="s-chapters">0</div><div style="font-size:12px; color:#888">章节</div></div>
                <div class="stat-card"><div class="stat-num" id="s-books">0</div><div style="font-size:12px; color:#888">书籍</div></div>
            </div>

            <!-- 图表 -->
            <!-- 热力图 -->
            <div style="margin-bottom:15px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                    <div style="font-size:12px; color:#888;">活跃度热力图 (最近半年)</div>
                </div>
                <div class="heatmap-container">
                    <div id="heatmapChart"></div>
                </div>
            </div>
            
            <div style="height:150px; position:relative;">
                <canvas id="trendChart"></canvas>
            </div>
        </div>
    </div>

    <!-- === 模态框: 标签编辑 === -->
    <div id="tagModal" class="p-modal">
        <div class="p-modal-content" style="width: 300px;">
            <h3 style="margin-top:0">🏷️ 编辑标签</h3>
            <input type="text" id="tagEditInput" class="p-input" style="margin:15px 0;">
            <input type="hidden" id="tagEditKey">
            <div style="text-align:right; gap:10px; display:flex; justify-content:flex-end;">
                <button class="p-btn p-btn-sm" onclick="PureUI.modal.close('tagModal')">取消</button>
                <button class="p-btn p-btn-sm p-btn-primary" onclick="saveTags()">保存</button>
            </div>
        </div>
    </div>
    <!-- 书单管理模态框 -->
    <div id="booklistModal" class="p-modal">
        <div class="p-modal-content" style="max-width: 500px;">
            <div style="display:flex; justify-content:space-between; margin-bottom:15px;">
                <h3 style="margin:0">📚 我的书单</h3>
                <!-- <button class="p-btn p-btn-sm" onclick="PureUI.modal.close('booklistModal')">✕</button> -->
            </div>
            <div style="display:flex; gap:10px; margin-bottom:20px;">
                <input type="text" id="newListName" class="p-input" placeholder="输入新书单名称...">
                <button class="p-btn p-btn-primary" onclick="createBooklist()">创建</button>
            </div>
            <div id="booklistContainer"><!-- 加载书单列表 --></div>
        </div>
    </div>
    
    <!-- 书单详情模态框 -->
    <div id="listDetailModal" class="p-modal">
        <div class="p-modal-content" style="max-width: 700px;">
            <div style="display:flex; justify-content:space-between; margin-bottom:15px;">
                <h3 style="margin:0" id="currentListName">书单详情</h3>
                <!-- <button class="p-btn p-btn-sm" onclick="PureUI.modal.close('listDetailModal')">✕</button> -->
            </div>
            <div class="booklist-kanban">
                <div class="kanban-column">
                    <div class="kanban-title">⭐ 想看</div>
                    <div id="col-want"></div>
                </div>
                <div class="kanban-column">
                    <div class="kanban-title">✅ 已看</div>
                    <div id="col-done"></div>
                </div>
            </div>
        </div>
    </div>
    <!-- 选择书单模态框 -->
<div id="addToListModal" class="p-modal">
    <div class="p-modal-content" style="max-width: 400px;">
        <div style="display:flex; justify-content:space-between; margin-bottom:15px;">
            <h3 style="margin:0">🔖 加入书单</h3>
            <!-- <button class="p-btn p-btn-sm" onclick="PureUI.modal.close('addToListModal')">✕</button> -->
        </div>
        <p id="addingBookName" style="font-size: 13px; color: #666; margin-bottom: 15px;"></p>
        <div id="selectListContainer" style="max-height: 300px; overflow-y: auto;">
            <!-- 这里由 JS 渲染书单列表 -->
        </div>
        <div style="text-align:right; margin-top:15px; border-top:1px solid #eee; padding-top:10px;">
            <button class="p-btn p-btn-sm" onclick="PureUI.modal.close('addToListModal')">取消</button>
        </div>
    </div>
</div>
<!-- 历史记录模态框 -->
<div id="historyModal" class="p-modal">
    <div class="p-modal-content" style="max-width: 500px;">
        <div style="display:flex; justify-content:space-between; margin-bottom:15px;">
            <h3 style="margin:0">⏳ 最近阅读</h3>
            <div>
                <button class="p-btn p-btn-sm p-btn-danger" onclick="clearHistory()">清空</button>
                <!-- <button class="p-btn p-btn-sm" onclick="PureUI.modal.close('historyModal')">✕</button> -->
            </div>
        </div>
        <div id="historyList" style="max-height: 400px; overflow-y: auto;">
            <!-- JS 渲染列表 -->
        </div>
    </div>
</div>
<!-- 版本回退模态框 -->
<div id="versionModal" class="p-modal">
    <div class="p-modal-content" style="max-width: 500px;">
        <div style="display:flex; justify-content:space-between; margin-bottom:15px;">
            <h3 style="margin:0">🕒 历史版本 (最近5次)</h3>
            <!-- <button class="p-btn p-btn-sm" onclick="PureUI.modal.close('versionModal')">✕</button> -->
        </div>
        <p id="versionBookName" style="font-size:13px; color:#666; margin-bottom:10px;"></p>
        <div id="versionList" style="max-height: 400px; overflow-y: auto;">
            <!-- JS 渲染列表 -->
        </div>
    </div>
</div>
<!-- 更新日志 Modal -->
<!-- 更新日志 Modal -->
<!-- 更新日志 Modal -->
<div id="changelogModal" class="p-modal">
    <div class="p-modal-content" style="max-width: 600px;">
        <div style="display:flex; justify-content:space-between; margin-bottom:15px; border-bottom: 1px solid #eee; padding-bottom: 10px;">
            <h3 style="margin:0">🎉 版本更新说明</h3>
            <!-- 右上角小叉叉（可选） -->
            <!-- <span style="cursor:pointer; font-size:20px; color:#999;" onclick="PureUI.modal.close('changelogModal')">×</span> -->
        </div>
        <!-- 注意：这里用 innerHTML 渲染 HTML -->
        <div id="changelogContent">正在获取更新内容...</div>
        <div style="text-align:right; margin-top:20px;">
            <!-- 核心：必须使用 PureUI.modal.close -->
            <button class="p-btn p-btn-primary" onclick="PureUI.modal.close('changelogModal')">我知道了</button>
        </div>
    </div>
</div>
<!-- 桌面设置 Modal -->
<!-- 桌面设置 Modal -->
<div id="desktopSettingsModal" class="p-modal">
    <div class="p-modal-content" style="max-width: 400px;">
        <div style="display:flex; justify-content:space-between; margin-bottom:15px;">
            <h3 style="margin:0">🖥️ 桌面客户端设置</h3>
        </div>
        
        <div class="setting-row" style="margin-bottom: 20px;">
            <label class="p-label">老板键 (显示/隐藏窗口)</label>
            <input type="text" id="bossKeyInput" class="p-input" placeholder="点击此处按下按键组合" readonly 
                   style="background: #f9fafb; cursor: pointer; text-align: center; font-weight: bold; color: #4f46e5;">
        </div>

        <div class="setting-row" style="margin-bottom: 10px;">
            <label class="p-label">停止朗读快捷键</label>
            <input type="text" id="ttsKeyInput" class="p-input" placeholder="点击此处按下按键组合" readonly 
                   style="background: #f9fafb; cursor: pointer; text-align: center; font-weight: bold; color: #4f46e5;">
        </div>

        <p style="font-size:12px; color:#888; line-height: 1.4;">
            💡 <b>使用说明：</b>点击输入框后，直接在键盘上按下你想要的组合键（如 Ctrl+Shift+Z），系统会自动录入。
        </p>

        <div style="text-align:right; margin-top:20px; gap:10px; display:flex; justify-content:flex-end;">
            <button class="p-btn p-btn-sm" onclick="PureUI.modal.close('desktopSettingsModal')">取消</button>
            <button class="p-btn p-btn-sm p-btn-primary" onclick="saveDesktopSettings()">保存并生效</button>
        </div>
    </div>
</div>
<!-- 更多操作菜单 (响应式 Modal) -->
<div id="moreMenuModal" class="p-modal more-menu-overlay">
    <div class="p-modal-content more-menu-content">
        <div style="padding: 15px; border-bottom: 1px solid #eee; font-weight: bold; text-align: center; color: #333; display:flex; justify-content:space-between; align-items:center;">
            <span id="moreMenuTitle">书籍操作</span>
            <span style="cursor:pointer; font-size:20px; color:#999;" onclick="PureUI.modal.close('moreMenuModal')">×</span>
        </div>
        
        <div class="menu-list" id="moreMenuItems">
            <!-- JS 生成列表 -->
        </div>
    </div>
</div>

<!-- 导出全书 Modal -->
<div id="exportModal" class="p-modal">
    <div class="p-modal-content" style="max-width:450px; border-radius:12px;">
        <div style="padding:20px 20px 15px; border-bottom:1px solid #eee; display:flex; justify-content:space-between; align-items:center;">
            <h3 style="margin:0; font-size:18px; color:#333;">📦 导出全书</h3>
            <span style="cursor:pointer; font-size:24px; color:#999; line-height:1;" onclick="PureUI.modal.close('exportModal')">×</span>
        </div>
        
        <div style="padding:20px;">
            <!-- 书名显示 -->
            <div style="margin-bottom:15px; padding:10px; background:#f9fafb; border-radius:6px;">
                <div style="font-size:12px; color:#666; margin-bottom:3px;">书名</div>
                <div id="exportBookName" style="font-weight:500; color:#333;">-</div>
            </div>
            
            <!-- 格式选择 -->
            <div style="margin-bottom:20px;">
                <div style="font-weight:500; margin-bottom:10px; color:#333;">选择格式</div>
                <div style="display:flex; gap:10px;">
                    <label style="flex:1; padding:12px; border:2px solid #e5e7eb; border-radius:8px; cursor:pointer; text-align:center; transition:all 0.2s;" onclick="selectExportFormat('txt', this)">
                        <input type="radio" name="exportFormat" value="txt" checked style="display:none;">
                        <div style="font-size:24px; margin-bottom:5px;">📄</div>
                        <div style="font-weight:500;">TXT</div>
                        <div style="font-size:11px; color:#666; margin-top:3px;">纯文本格式</div>
                    </label>
                    <label style="flex:1; padding:12px; border:2px solid #e5e7eb; border-radius:8px; cursor:pointer; text-align:center; transition:all 0.2s;" onclick="selectExportFormat('epub', this)">
                        <input type="radio" name="exportFormat" value="epub" style="display:none;">
                        <div style="font-size:24px; margin-bottom:5px;">📚</div>
                        <div style="font-weight:500;">EPUB</div>
                        <div style="font-size:11px; color:#666; margin-top:3px;">电子书格式</div>
                    </label>
                </div>
            </div>
            
            <!-- 速度控制 -->
            <div style="margin-bottom:20px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                    <span style="font-weight:500; color:#333;">抓取速度</span>
                    <span id="exportSpeedText" style="font-size:12px; color:#666;">中速 (0.5秒/章)</span>
                </div>
                <input type="range" id="exportDelaySlider" min="0.1" max="3.0" step="0.1" value="0.5" 
                    style="width:100%; accent-color:#4f46e5;" 
                    oninput="updateSpeedText(this.value)">
                <div style="display:flex; justify-content:space-between; font-size:11px; color:#999; margin-top:4px;">
                    <span>极速 (易被封)</span>
                    <span>慢速 (更安全)</span>
                </div>
            </div>
            
            <!-- 进度区域 -->
            <div id="exportProgressArea" style="display:none; margin-bottom:15px;">
                <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
                    <span id="exportStatusText" style="color:#666; font-size:14px;">准备中...</span>
                    <span id="exportProgressText" style="color:#666; font-size:14px;">0/0</span>
                </div>
                <div style="background:#e5e7eb; height:8px; border-radius:4px; overflow:hidden;">
                    <div id="exportProgressBar" style="background:linear-gradient(90deg,#4f46e5,#7c3aed); height:100%; width:0%; transition:width 0.3s;"></div>
                </div>
            </div>
            
            <!-- 错误提示 -->
            <div id="exportError" style="display:none; padding:12px; background:#fee2e2; border-radius:6px; color:#dc2626; font-size:14px; margin-bottom:15px;"></div>
            
            <!-- 操作按钮 -->
            <div style="display:flex; gap:10px;">
                <button id="exportCancelBtn" onclick="cancelExport()" style="flex:1; padding:12px; border:1px solid #e5e7eb; background:#fff; border-radius:8px; cursor:pointer; font-size:14px; font-weight:500; color:#666;">取消</button>
                <button id="exportPauseBtn" onclick="togglePause()" style="display:none; flex:1; padding:12px; border:1px solid #fb923c; background:#fff; color:#fb923c; border-radius:8px; cursor:pointer; font-size:14px; font-weight:500;">⏸ 暂停</button>
                <button id="exportStartBtn" onclick="startExportTask()" style="flex:1; padding:12px; border:none; background:#4f46e5; color:#fff; border-radius:8px; cursor:pointer; font-size:14px; font-weight:500;">开始导出</button>
            </div>
        </div>
    </div>
</div>

<!-- 导出历史 Modal -->
<div id="exportHistoryModal" class="p-modal">
    <div class="p-modal-content" style="max-width:600px; border-radius:12px;">
        <div style="padding:20px 20px 15px; border-bottom:1px solid #eee; display:flex; justify-content:space-between; align-items:center;">
            <h3 style="margin:0; font-size:18px; color:#333;">📦 导出记录</h3>
            <span style="cursor:pointer; font-size:24px; color:#999; line-height:1;" onclick="PureUI.modal.close('exportHistoryModal')">×</span>
        </div>
        
        <div style="padding:20px; max-height:500px; overflow-y:auto;" id="exportHistoryList">
            <!-- JS 渲染列表 -->
        </div>
    </div>
</div>

<!-- 下载管理 Modal (Pro 专属) -->
<div id="downloadsManagerModal" class="p-modal">
    <div class="p-modal-content" style="max-width:700px; border-radius:12px;">
        <div style="padding:20px 20px 15px; border-bottom:1px solid #eee; display:flex; justify-content:space-between; align-items:center;">
            <div>
                <h3 style="margin:0; font-size:18px; color:#333;">💾 下载管理</h3>
                <div style="font-size:12px; color:#666; margin-top:4px;">管理已导出的书籍文件</div>
            </div>
            <span style="cursor:pointer; font-size:24px; color:#999; line-height:1;" onclick="PureUI.modal.close('downloadsManagerModal')">×</span>
        </div>
        
        <div style="padding:20px; max-height:500px; overflow-y:auto;" id="downloadsList">
            <!-- JS 渲染列表 -->
        </div>
    </div>
</div>

    <script>
        const APP_VERSION = "{{ app_version }}"; 
        var tmp = "{{ api_url }}"
        var API_URL = window.location.origin;
        // var API_URL = "{{ api_url }}"
        // if (tmp.length() > 0) API_URL = tmp;
        // alert(tmp);
        let currentView = 'list';
        let currentData = {};
        let globalTags = {}; 
        let activeFilter = 'all';
        let insightData = null;
        let chartInstance = null;
        let allBooklists = {};
        let redDotsSet = new Set(); // [新增] 全局红点集合
        let pendingBook = { key: '', title: '' };
    
    // 🔥 重命名书签Key
    async function renameKey(oldKey) {
        // 关闭菜单
        PureUI.modal.close('moreMenuModal');
        
        // 延迟执行 prompt，防止阻塞 UI 渲染导致 Modal 关不掉
        setTimeout(async () => {
             const newKey = prompt(`请输入 [${oldKey}] 的新名字 (修改Key):`, oldKey);
             if (!newKey || newKey === oldKey) return;
             
             try {
                 const res = await fetch('/api/rename_key', {
                     method: 'POST',
                     headers: {'Content-Type': 'application/json'},
                     body: JSON.stringify({ old_key: oldKey, new_key: newKey })
                 });
                 const data = await res.json();
                 if (data.status === 'success') {
                     PureUI.notification.show('重命名成功', 'success');
                     setTimeout(() => location.reload(), 500);
                 } else {
                     PureUI.notification.show(data.message || '重命名失败', 'error');
                 }
             } catch (e) {
                 console.error(e);
                 PureUI.notification.show('请求不可达', 'error');
             }
        }, 100);
    }

    function openMoreMenu(key, value, title, isEpub, isLink) {
    document.getElementById('moreMenuTitle').innerText = title;
    const container = document.getElementById('moreMenuItems');
    
    // [修复] 转义单引号，防止 JS 语法错误导致点击无反应
    const safeKey = key.replace(/'/g, "\\'");
    const safeTitle = title.replace(/'/g, "\\'");
    const safeVal = value.replace(/'/g, "\\'");

    let html = '';
    const closeCmd = "PureUI.modal.close('moreMenuModal');";
    
    // [修复] 使用 setTimeout 确保 Modal 完整关闭后再执行 UI 阻塞操作 (如 prompt)
    const asyncAct = (script) => `${closeCmd} setTimeout(function(){ ${script} }, 100);`

    // 生成菜单项 (图标 + 文字)
    const items = [
        { icon: '🔖', text: '加入书单', click: asyncAct(`openAddToListModal('${safeKey}', '${safeTitle}')`) },
        { icon: '🏷️', text: '编辑标签', click: asyncAct(`openTagModal('${safeKey}')`) },
        { icon: '✏️', text: '重命名', click: asyncAct(`renameKey('${safeKey}')`) },
        { icon: '🕒', text: '历史回退', click: asyncAct(`openVersionModal('${safeKey}')`) },
        // { icon: '📥', text: '离线下载', click: `${closeCmd} downloadBook('${safeKey}', '${safeVal}', '${safeTitle}')` },
        { icon: '📦', text: '导出全书', click: asyncAct(`showExportModal('${safeKey}', '${encodeURIComponent(value)}')`) }
    ];

    if (isLink) {
        items.push({ icon: '🔗', text: '复制源链接', click: `${closeCmd} PureUI.copy('${safeVal}')` });
    }

    // 渲染普通项
    html += items.map(i => `
        <div class="action-item" onclick="${i.click}">
            <span style="width:24px; display:inline-block;">${i.icon}</span> ${i.text}
        </div>
    `).join('');

    // 渲染删除项 (红色)
    html += `
        <div class="action-item danger" onclick="${asyncAct(`document.getElementById('key').value='${safeKey}'; confirmDelete()`)}">
            <span style="width:24px; display:inline-block;">🗑️</span> 删除书籍
        </div>`;

    container.innerHTML = html;
    PureUI.modal.open('moreMenuModal');
}

// 🔥 重命名书签Key
async function renameKey(oldKey) {
    const newKey = prompt(`📝 为 [${oldKey}] 起个新名字：`, oldKey);
    if (!newKey || newKey === oldKey) return;
    
    PureUI.loading.show('正在重命名...');
    try {
        const res = await fetch('/api/rename_key', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ old_key: oldKey, new_key: newKey })
        });
        const json = await res.json();
        
        if (json.status === 'success') {
            showMsg(json.msg, 'success');
            // 刷新列表
            doAction('list');
            // 如果当前输入框显示的是旧Key，替换成新的
            if (document.getElementById('key').value === oldKey) {
                document.getElementById('key').value = newKey;
            }
        } else {
            showMsg(json.msg, 'error');
        }
    } catch(e) {
        showMsg('网络错误', 'error');
    } finally {
        PureUI.loading.hide();
    }
}

        document.addEventListener('keydown', (e) => {
    // 1. Ctrl + F 快速搜书 (覆盖浏览器默认搜索)
    if (e.ctrlKey && e.key === 'f') {
        e.preventDefault();
        openSearchModal();
    }
    
    // 2. Ctrl + S 快速保存当前输入
    if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        doAction('insert');
    }

    // 3. / 键快速聚焦到 Key 输入框 (类似 GitHub)
    if (e.key === '/' && document.activeElement.tagName !== 'INPUT') {
        e.preventDefault();
        document.getElementById('key').focus();
    }
});
// 打开“加入书单”选择框
async function openAddToListModal(key, title) {
    pendingBook = { key, title };
    document.getElementById('addingBookName').innerText = `书籍：${title}`;
    
    // 获取最新书单
    const res = await fetch('/api/booklists/all');
    const json = await res.json();
    allBooklists = json.data;

    const cont = document.getElementById('selectListContainer');
    let html = '';
    
    const listIds = Object.keys(allBooklists);
    if (listIds.length === 0) {
        html = '<div style="text-align:center; padding:20px; color:#999;">你还没有创建任何书单</div>';
    } else {
        listIds.forEach(id => {
            html += `
            <div class="list-item-card" style="padding:10px; border:1px solid #eee; margin-bottom:8px; cursor:pointer; border-radius:6px;" onclick="confirmAddToList('${id}')">
                <div style="font-weight:600;">${allBooklists[id].name}</div>
                <div style="font-size:11px; color:#888;">${allBooklists[id].books.length} 本书</div>
            </div>`;
        });
    }
    cont.innerHTML = html;
    PureUI.modal.open('addToListModal');
}

// 确认加入
async function confirmAddToList(listId) {
    try {
        const res = await fetch('/api/booklists/add_book', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                list_id: listId,
                book_data: { key: pendingBook.key, title: pendingBook.title, status: 'want' }
            })
        });
        const data = await res.json();
        if (data.status === 'success') {
            showMsg(`已加入书单：${allBooklists[listId].name}`, 'success');
            PureUI.modal.close('addToListModal');
        }
    } catch (e) {
        showMsg("加入失败", "error");
    }
}
async function openBooklists() {
    const res = await fetch('/api/booklists/all');
    const json = await res.json();
    allBooklists = json.data;
    renderBooklistManager();
    PureUI.modal.open('booklistModal');
}

function renderBooklistManager() {
    const cont = document.getElementById('booklistContainer');
    let html = '';
    Object.keys(allBooklists).forEach(id => {
        const list = allBooklists[id];
        html += `
        <div class="list-item-card" onclick="viewListDetail('${id}')">
            <div>
                <span style="font-weight:600;">${list.name}</span>
                <div style="font-size:12px; color:#888;">共 ${list.books.length} 本书</div>
            </div>
            <div style="color:var(--p-primary)">查看 →</div>
        </div>`;
    });
    cont.innerHTML = html || '<div style="text-align:center; color:#999; padding:20px;">暂无书单</div>';
}
// 专门处理删除确认的逻辑
async function confirmDelete() {
    const key = document.getElementById('key').value.trim();
    
    // 1. 检查是否输入了 Key
    if (!key) {
        showMsg('请输入要删除的 Key', 'error');
        return;
    }

    // 2. 弹出原生确认框
    // 提示信息包含具体的 Key 名称，防止删错
    const warningText = `⚠️ 危险操作！\n\n确定要彻底删除 [${key}] 吗？\n这将清除该书的所有阅读进度和配置。`;
    
    if (confirm(warningText)) {
        // 用户点击“确定”后才执行真正的删除
        doAction('remove');
    }
}
async function createBooklist() {
    const name = document.getElementById('newListName').value.trim();
    if(!name) return;
    await fetch('/api/booklists/create', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({name}) });
    document.getElementById('newListName').value = '';
    openBooklists(); // 刷新
}

function viewListDetail(listId) {
    const list = allBooklists[listId];
    if (!list) {
        showMsg("该书单不存在", "error");
        return;
    }
    document.getElementById('currentListName').innerText = list.name;
    const wantCont = document.getElementById('col-want');
    const doneCont = document.getElementById('col-done');
    wantCont.innerHTML = ''; doneCont.innerHTML = '';

    list.books.forEach(book => {
        const bg = stringToColor(book.title);
        
        // [修改点 1] 外层 div 增加 cursor:pointer 和 onclick 事件
        const html = `
        <div class="mini-book-card" style="cursor:pointer;" onclick="selectBookFromList('${book.key}')" title="点击跳转到书架">
            <div class="mini-book-info">
                <div class="mini-book-dot" style="background:${bg}"></div>
                <div style="font-size:14px; font-weight:500;">${book.title}</div>
            </div>
            
            <div class="action-group">
                <!-- [修改点 2] 内部按钮增加 event.stopPropagation() 防止冒泡 -->
                ${book.status === 'want' ? 
                    `<button class="p-btn p-btn-sm" onclick="event.stopPropagation(); updateBookStatus('${listId}', '${book.key}', 'done')">✅</button>` : 
                    `<button class="p-btn p-btn-sm" onclick="event.stopPropagation(); updateBookStatus('${listId}', '${book.key}', 'want')">⏪</button>`}
                
                <button class="p-btn p-btn-sm p-btn-danger" style="padding:2px 5px;" onclick="event.stopPropagation(); updateBookStatus('${listId}', '${book.key}', '', 'remove')">×</button>
            </div>
        </div>`;
        
        if(book.status === 'want') wantCont.innerHTML += html;
        else doneCont.innerHTML += html;
    });
    PureUI.modal.open('listDetailModal');
}

async function updateBookStatus(listId, bookKey, status, action='update') {
    const res = await fetch('/api/booklists/update_book', {
        method:'POST', headers:{'Content-Type':'application/json'}, 
        body:JSON.stringify({list_id: listId, book_key: bookKey, status, action})
    });
    const json = await res.json();
    allBooklists = json.data;
    viewListDetail(listId); // 刷新详情
}

// 补充功能：在主界面表格增加“加入书单”入口
// 你可以在 renderTable 的 actionGroup 里加个按钮，调用这个函数
async function addBookToList(bookKey, bookTitle) {
    const listId = prompt("请输入书单ID (可在书单管理查看)"); // 这里简单实现，之后可以改成下拉选择
    if(!listId) return;
    await fetch('/api/booklists/add_book', {
        method:'POST', headers:{'Content-Type':'application/json'},
        body:JSON.stringify({ list_id: listId, book_data: {key: bookKey, title: bookTitle, status: 'want'} })
    });
    showMsg("已加入想看清单", "success");
}
        // 辅助: 颜色生成
        function stringToColor(str) {
            let hash = 0; for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
            return `hsl(${Math.abs(hash) % 360}, ${60 + (Math.abs(hash) % 20)}%, ${40 + (Math.abs(hash) % 20)}%)`;
        }

        // 显示消息 (兼容 PureUI Toast)
        function showMsg(text, type='info') {
            const box = document.getElementById('msgBox');
            box.innerText = text;
            box.className = type === 'error' ? 'error' : 'success';
            box.style.display = 'block';
            setTimeout(() => box.style.display = 'none', 3000);
        }
function checkAppVersion() {
    const lastVersion = localStorage.getItem('last_seen_version');
    if (lastVersion !== APP_VERSION) {
        // 第一次访问或版本变动，自动弹出
        showChangelog(true); 
    }
}

// 3. 获取并显示日志
async function showChangelog(isAutoPopup = false) {
    const container = document.getElementById('changelogContent');
    
    // 1. 先打开 Modal 显示加载中
    PureUI.modal.open('changelogModal');
    container.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">正在获取更新记录...</div>';

    try {
        // 2. 异步读入 change.html
        const response = await fetch('/static/change.html?t=' + new Date().getTime());
        if (response.ok) {
            const html = await response.text();
            container.innerHTML = html; // 将读到的内容写入容器

            // 3. 高亮并滚动到当前版本
            // 使用 getElementById 处理带点的版本号 ID
            const currentBlock = document.getElementById(APP_VERSION);
            if (currentBlock) {
                currentBlock.classList.add('active-ver');
                
                // 延迟执行滚动，确保浏览器完成重绘
                setTimeout(() => {
                    currentBlock.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 200);
            }

            // 4. 如果是新版本第一次见，记录版本号
            if (isAutoPopup) {
                localStorage.setItem('last_seen_version', APP_VERSION);
            }
        } else {
            container.innerHTML = '<p style="color:#999; text-align:center;">未找到 change.html 文件。</p>';
        }
    } catch (e) {
        console.error("ChangeLog Load Error:", e);
        container.innerHTML = '<p style="color:red; text-align:center;">无法连接到服务器加载日志。</p>';
    }
}
       // 初始化
        window.onload = function() {
            checkAppVersion();
            // 用户
            // index.html 中的 script

// ...
fetch('/api/me').then(r => r.json()).then(user => {
    if (user.username) {
        document.getElementById('userName').innerText = user.username;
        if (user.avatar) document.getElementById('userAvatar').src = user.avatar;
        
        // [新增] 角色判断逻辑
        const role = user.role || 'user';
        const roleBadge = document.getElementById('userRoleBadge');
        const adminBtn = document.getElementById('adminEntryBtn');

        // 显示角色标签
        if (role === 'admin') {
            roleBadge.innerText = "ADMIN";
            roleBadge.style.display = "inline-block";
            roleBadge.style.background = "#ef4444"; // 红色
            roleBadge.style.color = "white";
            
            // [核心] 如果是管理员，显示入口按钮
            adminBtn.style.display = "inline-flex";
        } else if (role === 'pro') {
            roleBadge.innerText = "PRO";
            roleBadge.style.display = "inline-block";
            roleBadge.style.background = "#fbbf24"; // 金色
            roleBadge.style.color = "white";
        }
    }
});
setInterval(fetchUpdates, 600000); // 10分钟一次
// ...

            // 数据：首页默认显示“历史”列表（最近 -> 最远）
            loadBooks().then(fetchTags);
            fetchUpdates();

            // 仅填充上次阅读的 key/value（不触发列表刷新）
            fetch('/api/last_read').then(r=>r.json()).then(async d => {
                if(d.key) {
                    document.getElementById('key').value = d.key;
                    try {
                        const vRes = await fetch('/api/get_value', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({key:d.key})});
                        const vData = await vRes.json();
                        if(vData.status==='success') document.getElementById('value').value = vData.value;
                    } catch(e){}
                }
            }).catch(()=>{});

            // 拖拽
            const vInput = document.getElementById('value');
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => vInput.addEventListener(e, (ev)=>{ev.preventDefault();ev.stopPropagation()}, false));
            vInput.addEventListener('dragenter', ()=>vInput.classList.add('drag-over'));
            vInput.addEventListener('dragover', ()=>vInput.classList.add('drag-over'));
            vInput.addEventListener('dragleave', ()=>vInput.classList.remove('drag-over'));
            vInput.addEventListener('drop', handleDrop);
        };
        setInterval(() => {
            console.log("⏰ 自动刷新更新状态...");
            fetchUpdates();
        }, 600000);
        function handleEnter(e) {
            if (e.key !== 'Enter') return;
            if (e.target.id === 'value') doAction('insert'); else if (e.target.id === 'key') doAction('find');
        }
        
        // 检查 URL 参数自动保存
        (function checkAutoSave() {
            const urlParams = new URLSearchParams(window.location.search);
            const autoSaveKey = urlParams.get('key');
            const autoSaveUrl = urlParams.get('url');
            
            if (autoSaveKey) {
                console.log('🔄 检测到 URL 参数，自动保存:', autoSaveKey);
                document.getElementById('key').value = autoSaveKey;
                if (autoSaveUrl) {
                    document.getElementById('value').value = autoSaveUrl;
                }
                // 延迟执行以确保页面加载完成
                setTimeout(() => {
                    doAction('insert');
                    // 清除 URL 参数
                    window.history.replaceState({}, document.title, window.location.pathname);
                }, 500);
            }
        })();

        // 核心操作
        async function doAction(action) {
            const key = document.getElementById('key').value.trim();
            const value = document.getElementById('value').value.trim();
            if (action === 'find' && !key) {
                action = 'list';
            } else if (action !== 'list' && action !== 'find' && !key) {
                // 其他操作 (insert/remove) 依然必须有 key
                return showMsg('请输入 Key', 'error');
            }

            if (action === 'list' || action === 'update') {
                homeMode = 'books';
            }

            PureUI.loading.show(action === 'insert' ? '保存中...' : action === 'find' ? '查询中...' : '加载中...');
            const btn = document.activeElement; if(btn && btn.tagName === 'BUTTON') btn.classList.add('loading');
            const payload = { key, value };
            if (action === 'insert' || action === 'update') {
                payload.manual = true; // 标记为手动保存，触发历史记录
            }
            try {
                const res = await fetch(`${API_URL}/${action}`, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify(payload) 
                });
                const result = await res.json();
                
                if (['insert', 'update', 'remove', 'rollback'].includes(action)) {
                    if(result.status === 'success') {
                        showMsg(action + ' 成功', 'success');
                        if (action === 'insert' || action === 'update') doAction('find'); else doAction('list');
                    } else showMsg(result.message || '操作失败', 'error');
                } else if (result.data) {
                    renderTable(result.data);
                    if(action === 'find' && Object.keys(result.data).length === 0) showMsg("未找到相关记录");
                }
            } catch (err) { showMsg('网络错误', 'error'); } 
            finally { 
                PureUI.loading.hide();
                if(btn && btn.tagName === 'BUTTON') btn.classList.remove('loading'); 
            }
        }
        let homeMode = 'history';
        let historyOrder = [];
        let fullDataCache = null;

        // 格式化时间戳
function formatTime(timestamp) {
    const date = new Date(timestamp * 1000);
    return `${date.getMonth()+1}-${date.getDate()} ${date.getHours()}:${date.getMinutes().toString().padStart(2, '0')}`;
}


async function openHistory() {
    const res = await fetch('/api/history/list');
    const json = await res.json();
    const list = json.data;
    const container = document.getElementById('historyList');
    
    if (!list || list.length === 0) {
        container.innerHTML = '<div style="text-align:center; color:#999; padding:20px;">暂无阅读记录</div>';
    } else {
        let html = '';
        list.forEach(item => {
            const bg = stringToColor(item.key); // 用书名Key生成头像颜色
            html += `
            <div class="list-item-card" onclick="window.open('/read?url=${encodeURIComponent(item.url)}&key=${encodeURIComponent(item.key)}', '_blank')">
                <div style="display:flex; align-items:center; gap:10px; width:100%;">
                    <div style="width:36px; height:36px; border-radius:6px; background:${bg}; color:white; display:flex; align-items:center; justify-content:center; font-weight:bold; font-size:12px; flex-shrink:0;">
                        ${item.key.slice(0, 2).toUpperCase()}
                    </div>
                    <div style="overflow:hidden;">
                        <div style="font-weight:600; font-size:14px; color:#374151;">${item.key}</div>
                        <div style="font-size:12px; color:#6b7280; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                            ${item.title}
                        </div>
                    </div>
                </div>
                <div style="font-size:12px; color:#9ca3af; white-space:nowrap; margin-left:10px;">
                    ${formatTime(item.timestamp)}
                </div>
            </div>`;
        });
        container.innerHTML = html;
    }
    PureUI.modal.open('historyModal');
}
// [新增] 从书单选中书籍跳转
function selectBookFromList(key) {
    // 1. 填入 Key
    document.getElementById('key').value = key;
    
    // 2. 关闭所有相关模态框 (先关详情，再关列表)
    PureUI.modal.close('listDetailModal');
    PureUI.modal.close('booklistModal');
    
    // 3. 触发“查库”操作
    doAction('find');
}
async function clearHistory() {
    if(confirm("确定清空所有阅读历史吗？")) {
        await fetch('/api/history/clear', { method: 'POST' });
        openHistory(); // 刷新
    }
}
async function showActionSheet(key, url) {
        // 如果是手机端，显示底部抽屉；如果是PC，显示中间弹窗（已有的逻辑）
        // 这里重点是动态往里面加内容
        
        // 1. 准备基础菜单
        let menuHtml = `
            <div style="padding:15px; border-bottom:1px solid #eee; font-weight:bold; color:#666; font-size:14px; text-align:center;">
                ${key}
            </div>
            <div class="action-item" onclick="window.location.href='/read?url=${encodeURIComponent(url)}&key=${encodeURIComponent(key)}'">
                📖 开始阅读
            </div>
            <div class="action-item" onclick="openHistoryVersions('${key}')">
                🕒 历史回退
            </div>
             <div class="action-item" onclick="showTagModal('${key}')">
                🏷️ 管理标签
            </div>
            <div class="action-item" onclick="showExportModal('${key}', '${encodeURIComponent(url)}')">
                📦 导出全书
            </div>
        `;
        
        // 2. [新增] 异步查询订阅状态，动态添加按钮
        // 为了显示“加载中”或默认状态，我们可以先显示一个 loading 占位
        menuHtml += `<div id="menuSubBtn" class="action-item" style="color:#666;">⏳ 查询追更状态...</div>`;
        
        // 3. 基础功能继续
        menuHtml += `
            <div class="action-item" onclick="confirmDelete('${key}')" style="color:#ef4444;">
                🗑️ 删除书籍
            </div>
        `;

        // 渲染弹窗
        // 假设你要用现有的 layer 或自定义 modal
        // 这里复用你以前可能存在的 showModal 逻辑，或者直接用 SweetAlert/Layer
        // 为了兼容性，我这里写一个简单的覆盖层逻辑
        
        const overlay = document.createElement('div');
        overlay.style.position = 'fixed'; overlay.style.top = '0'; overlay.style.left = '0';
        overlay.style.width = '100%'; overlay.style.height = '100%';
        overlay.style.background = 'rgba(0,0,0,0.5)'; overlay.style.zIndex = '9999';
        overlay.style.display = 'flex'; overlay.style.justifyContent = 'center'; overlay.style.alignItems = 'end';
        
        // 适配 PC 居中
        if (window.innerWidth > 600) overlay.style.alignItems = 'center';

        const content = document.createElement('div');
        content.style.background = '#fff'; content.style.width = '100%'; content.style.maxWidth = '400px';
        content.style.borderRadius = window.innerWidth > 600 ? '12px' : '16px 16px 0 0';
        content.style.overflow = 'hidden';
        content.innerHTML = menuHtml;
        
        overlay.appendChild(content);
        document.body.appendChild(overlay);
        
        // 点击遮罩关闭
        overlay.onclick = (e) => { if(e.target === overlay) document.body.removeChild(overlay); };

        // 绑定关闭事件到 window，方便特定回调关闭
        window.closeActionSheet = () => { try { document.body.removeChild(overlay); } catch(e){} };

        // [核心] 异步逻辑执行：去后端查状态
        try {
            const res = await fetch('/api/updates/status', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ key: key })
            });
            const json = await res.json();
            const btn = document.getElementById('menuSubBtn');
            const refreshBtn = document.getElementById('menuRefreshBtn');
            
            if (json.subscribed) {
                btn.innerHTML = `🔕 取消自动追更`;
                btn.onclick = () => toggleSubInMenu(key, false, url);
                btn.style.color = "#d97706"; // 橙色
                
                // 🔥 显示"立即检查更新"按钮
                if(refreshBtn) {
                    refreshBtn.style.display = 'block';
                    refreshBtn.onclick = () => manualCheckUpdate(key, url);
                }
            } else {
                btn.innerHTML = `🔔 开启自动追更`;
                btn.onclick = () => toggleSubInMenu(key, true, url);
                btn.style.color = "#059669"; // 绿色
            }
        } catch(e) {
            const btn = document.getElementById('menuSubBtn');
            if(btn) btn.innerText = "⚠️ 追更服务不可用";
        }
    }
        async function doRollback() {
            if(!confirm("确定回退到上一步吗？")) return;
            const res = await fetch(`${API_URL}/rollback`, { method: 'POST' });
            const result = await res.json();
            if(result.status === 'success') { showMsg('已回退', 'success'); doAction('list'); }
            else showMsg(result.message, 'error');
        }

        // 标签系统
        async function fetchTags() {
            const res = await fetch(`${API_URL}/api/tags/list`);
            const json = await res.json();
            if (json.status === 'success') {
                globalTags = json.data;
                renderFilterBar();
                if (currentData && Object.keys(currentData).length > 0) renderTable(currentData);
            }
        }
        function renderBookshelf(books) {
        const grid = document.getElementById('bookshelfGrid');
        grid.innerHTML = '';
        books.forEach(book => {
            // ... (域名解析逻辑) ...
            let domain = '本地';
            try { domain = new URL(book.val).hostname; } catch(e) {}
            
            const div = document.createElement('div');
            div.className = 'book-card';
            div.onclick = () => window.location.href = `/read?url=${encodeURIComponent(book.val)}&key=${encodeURIComponent(book.key)}`;
            
            // [新增] 红点 HTML
            let dotHtml = '';
            if (redDotsSet.has(book.key)) {
                dotHtml = `<div title="有新章节更新" style="position:absolute; top:8px; right:8px; width:10px; height:10px; background:#ef4444; border-radius:50%; border:2px solid white; box-shadow:0 2px 4px rgba(0,0,0,0.2); z-index:10;"></div>`;
            }

            // [修改] 增加长按菜单触发 (可选)
            div.oncontextmenu = (e) => { e.preventDefault(); showActionSheet(book.key, book.val); };

            div.innerHTML = `
                <div class="book-cover" style="background:${getGradient(book.key)}">
                    ${dotHtml}
                    <div class="book-title-card">${book.key}</div>
                    <div style="font-size:12px; margin-top:5px; opacity:0.8;">${domain}</div>
                </div>
                <div class="book-info-row">
                    <span>最后阅读...</span>
                    <!-- 点击菜单按钮，阻止冒泡防止跳转 -->
                    <span onclick="event.stopPropagation(); showActionSheet('${book.key}', '${book.val}')" style="padding:5px 10px; margin:-5px -10px; cursor:pointer; color:#999;">⋮</span>
                </div>
            `;
            grid.appendChild(div);
        });
        
        // 渲染加号
        const addDiv = document.createElement('div');
        addDiv.className = 'book-card';
        addDiv.style.border = '2px dashed #eee';
        addDiv.style.boxShadow = 'none';
        addDiv.onclick = () => document.getElementById('key').focus();
        addDiv.innerHTML = `<div style="flex:1; display:flex; justify-content:center; align-items:center; color:#ccc; font-size:40px;">+</div>`;
        grid.appendChild(addDiv);
    }
        // index.html -> script -> renderFilterBar
        async function toggleSubInMenu(key, enable, url) {
        window.closeActionSheet(); // 先关弹窗
        
        showMsg('正在处理...', 'normal');
        
        // 获取 cid (简易版：不爬虫了，直接设为 0，让后台第一次全量爬或者手动点进去一次更新)
        // 或者如果能从 user_db 拿到 value 也可以
        let cid = 0;
        const m = url.match(/\/(\d+)(?:_\d+)?(?:\.html)?$/);
        if (m) cid = parseInt(m[1]);

        try {
            const res = await fetch('/api/updates/subscribe', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ 
                    key: key, 
                    enable: enable, 
                    toc_url: url, // 暂用正文URL混一下，后台爬虫会自动跳目录
                    current_id: cid 
                })
            });
            const json = await res.json();
            if (json.status === 'success') {
                showMsg(json.msg, 'success');
                // 刷新一下红点状态 (如果是取消订阅，红点应该消失)
                if (!enable) {
                    redDotsSet.delete(key);
                    renderBookshelf(currentBooks); // 重绘
                }
            } else {
                showMsg(json.msg, 'error');
            }
        } catch(e) { showMsg('网络错误', 'error'); }
    }
    
    // 🔥 新增：手动检查更新
    async function manualCheckUpdate(key, url) {
        window.closeActionSheet();
        PureUI.loading.show('🔍 正在检查更新...');
        
        try {
            const res = await fetch('/api/updates/manual_check', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ key: key, toc_url: url })
            });
            const json = await res.json();
            
            if (json.status === 'success') {
                if (json.has_update) {
                    showMsg(`🎉 发现更新！最新：${json.latest_title}`, 'success');
                    redDotsSet.add(key);
                    renderBookshelf(currentBooks);
                } else {
                    showMsg('✅ 已是最新章节', 'success');
                }
            } else {
                showMsg(json.msg || '更新失败', 'error');
            }
        } catch(e) {
            showMsg('网络错误', 'error');
        } finally {
            PureUI.loading.hide();
        }
    }
    
let lastTagHash = ''; // 用于缓存标签指纹
function renderFilterBar() {
    const sourceData = (homeMode === 'history' && fullDataCache) ? fullDataCache : currentData;
    // 🔥 性能优化：只在标签真正变化时才重渲染
    const newHash = JSON.stringify({
        tags: Object.keys(globalTags).sort(),
        filter: activeFilter,
        dataKeys: sourceData ? Object.keys(sourceData).sort() : []
    });
    
    if (newHash === lastTagHash) return; // 指纹相同，跳过渲染
    lastTagHash = newHash;
    
    const bar = document.getElementById('filterBar');
    const allUniqueTags = new Set();
    
    // 遍历当前所有书籍数据
    if (sourceData) {
        Object.keys(sourceData).forEach(key => {
            // 跳过系统键
            if (key.startsWith('@') || key.endsWith(':meta')) return;

            // 1. 收集用户标签
            const uTags = globalTags[key] || [];
            uTags.forEach(t => allUniqueTags.add(t));

            // 2. [新增] 收集官方标签
            const valObj = sourceData[key];
            if (typeof valObj === 'object' && valObj !== null && valObj.official_tags) {
                valObj.official_tags.forEach(t => allUniqueTags.add(t));
            }
        });
    }

    // 渲染 HTML
    let html = `<span class="p-tag filter-chip ${activeFilter === 'all' ? 'active' : ''}" onclick="filterByTag('all')">全部</span>`;
    
    // 排序并生成标签
    Array.from(allUniqueTags).sort().forEach(tag => {
        const isActive = activeFilter === tag ? 'active' : '';
        // 给官方标签和用户标签一样的样式，或者你可以加个 class 区分
        html += `<span class="p-tag filter-chip ${isActive}" onclick="filterByTag('${tag}')">${tag}</span>`;
    });
    
    bar.innerHTML = html;
}

        function filterByTag(tag) {
            activeFilter = tag;
            if (homeMode === 'history' && fullDataCache) {
                homeMode = 'books';
                renderTable(fullDataCache);
                return;
            }
            renderFilterBar();
            renderTable(currentData);
        }

        function switchView(view) {
            if (homeMode === 'history') return;
            currentView = view;
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                if(btn.innerText.includes(view === 'list' ? '列表' : '网格')) btn.classList.add('active');
                else btn.classList.remove('active');
            });
            if (currentData) renderTable(currentData);
        }

        // 列表/网格渲染
        // === 在 index.html 的 <script> 标签内 ===
            async function renameKey(oldKey) {
    const newKey = prompt(`请输入 [${oldKey}] 的新名字:`, oldKey);
    
    if (!newKey || newKey === oldKey) return;

    try {
        const res = await fetch('/api/rename_key', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ old_key: oldKey, new_key: newKey })
        });
        const data = await res.json();
        
        if (data.status === 'success') {
            showMsg(data.message, 'success');
            // 如果修改的是当前正在编辑的 Key，同步更新输入框
            if (document.getElementById('key').value === oldKey) {
                document.getElementById('key').value = newKey;
            }
            // 刷新列表
            doAction('find');
            // 刷新标签展示
            fetchTags();
        } else {
            showMsg(data.message, 'error');
        }
    } catch (e) {
        showMsg("网络请求失败", "error");
    }
}
function renderTable(data) {
    const filterBar = document.getElementById('filterBar');
    const viewToggle = document.getElementById('viewToggleBar');
    if (homeMode !== 'history') {
        if (filterBar) filterBar.style.display = '';
        if (viewToggle) viewToggle.style.display = '';
    }

    currentData = data;
    const container = document.getElementById('tableContainer');
    let filteredKeys = Object.keys(data).filter(k => !k.startsWith('@') && !k.endsWith(':meta'));

    // 历史模式：按历史顺序渲染，跳过标签过滤
    if (homeMode === 'history') {
        activeFilter = 'all';
        if (filterBar) filterBar.style.display = '';
        if (viewToggle) viewToggle.style.display = 'none';
        renderFilterBar();
        if (historyOrder && historyOrder.length > 0) {
            filteredKeys = historyOrder.filter(k => data[k]);
        }
    } else {
        renderFilterBar();
    }

    // === [核心修改] 过滤逻辑升级 ===
    if (homeMode !== 'history' && activeFilter !== 'all') {
        filteredKeys = filteredKeys.filter(k => {
            const valObj = data[k];
            
            // 1. 检查用户标签
            const uTags = globalTags[k] || [];
            if (uTags.includes(activeFilter)) return true;

            // 2. 检查官方标签
            if (typeof valObj === 'object' && valObj !== null && valObj.official_tags) {
                if (valObj.official_tags.includes(activeFilter)) return true;
            }

            return false;
        });
    }
    if (homeMode !== 'history' && activeFilter !== 'all') {
        filteredKeys = filteredKeys.filter(k => (globalTags[k] || []).includes(activeFilter));
    }
    
    if (filteredKeys.length === 0) { 
        container.innerHTML = '<div style="text-align:center;padding:40px;color:#999">空空如也</div>'; 
        return; 
    }
    if (homeMode !== 'history') {
        filteredKeys.sort();
    }

    if (currentView === 'grid') return renderGrid(data, container, filteredKeys);

    let html = '<div class="book-list-container">';
    
    filteredKeys.forEach(k => {
        let valObj = data[k];
        let url = "", cover = "", author = "未知", desc = "暂无简介", lastRead = 0;
        let officialTags = valObj.official_tags || [];

        const userTags = globalTags[k] || []; // 用户标签
        // 兼容旧数据
        if (typeof valObj === 'object' && valObj !== null) {
            url = valObj.url || "";
            cover = valObj.cover || "";
            author = valObj.author || "未知";
            desc = valObj.desc || "暂无简介";
            lastRead = valObj.last_read_at || 0;
        } else {
            url = valObj;
        }

        const tags = globalTags[k] || [];
        const parts = k.split('/');
        const displayName = parts[parts.length-1];
        
        const isLink = url.startsWith('http') || url.startsWith('https');
        const isEpub = url.startsWith('epub:');

        // 封面
        let dotStyle = 'display:none';
        if (updatesCache[k] && updatesCache[k].unread_count > 0) {
            // 列表模式下，红点放在封面右上角，稍小一点
            dotStyle = 'position:absolute; top:-3px; right:-3px; width:8px; height:8px; background:#ef4444; border-radius:50%; border:1px solid white; z-index:10; box-shadow: 0 1px 2px rgba(0,0,0,0.2);';
        }

        // 封面 HTML 构建
        let coverHtml = '';
        if (cover) {
            // 给 img 外层包一个 relative 的 div，以便绝对定位红点
            coverHtml = `<div style="position:relative; display:inline-block;">
                            <img src="${cover}" class="book-cover-img" loading="lazy" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'">
                            <div class="book-cover-default" style="display:none">${displayName[0]}</div>
                            <div style="${dotStyle}"></div> <!-- 红点 -->
                         </div>`;
        } else {
            const bg = stringToColor(displayName);
            coverHtml = `<div style="position:relative; display:inline-block;">
                            <div class="book-cover-default" style="background:${bg}; color:white;">${displayName[0]}</div>
                            <div style="${dotStyle}"></div> <!-- 红点 -->
                         </div>`;
        }

        // 标签
        let tagsHtml = userTags.map(t => 
            `<span class="tag-badge">${t}</span>`
        ).join('');
        let officialTagsHtml = officialTags.slice(0, 3).map(t => 
            `<span class="tag-badge" style="background:#e0f2fe; color:#0369a1;">${t}</span>`
        ).join('');
        let allTagsHtml = tagsHtml + officialTagsHtml;
        // 操作按钮组 (Vertical Layout)
        let actionGroup = `
            <div class="action-col">
                ${isLink || isEpub ? 
                    `<a href="/read?url=${encodeURIComponent(url)}&key=${encodeURIComponent(k)}" class="act-btn act-primary">📖 阅读</a>` : ''
                }
                
                <button class="act-btn act-outline" id="upd-${k}" onclick="checkUpdate('${k}', '${url}')" title="检查更新">
                    🔄 更新
                </button>
                
                <!-- 更多按钮 (次级样式) -->
                <button class="act-btn act-outline" onclick="openMoreMenu('${k}', '${url}', '${displayName}', ${isEpub}, ${isLink})" title="更多操作">
                    ⋮ 更多
                </button>
            </div>
        `;

        html += `
        <div class="book-row">
            ${coverHtml}
            <div class="book-info">
                <div>
                    <div class="book-header">
                        <span class="book-title">${displayName}</span>
                        ${allTagsHtml}  <!-- 这里放入组合后的标签 -->
                    </div>
                    <div class="book-meta">
                        <span>👤 ${author}</span>
                        ${lastRead ? `<span>🕒 ${formatTime(lastRead).split(' ')[0]}</span>` : ''}
                    </div>
                    <div class="book-desc">${desc}</div>
                </div>
            </div>
            ${actionGroup}
        </div>`;
    });

    html += '</div>';
    container.innerHTML = html;
    renderUpdates();
}
async function openVersionModal(key) {
    document.getElementById('versionBookName').innerText = `书籍 Key: ${key}`;
    const cont = document.getElementById('versionList');
    cont.innerHTML = '<div style="text-align:center; padding:20px;">加载中...</div>';
    PureUI.modal.open('versionModal');

    try {
        const res = await fetch('/api/history/versions', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ key: key })
        });
        const json = await res.json();
        
        if (json.status === 'success' && json.data.length > 0) {
            let html = '';
            json.data.forEach(v => {
                // 格式化时间 (UTC转本地)
                const date = new Date(v.time + "Z"); // 假设数据库存的是UTC字符串，如果是时间戳需调整
                // 兼容 SQLite timestamp 格式 (通常是 "2023-01-01 12:00:00")
                const timeStr = v.time.replace('T', ' ').split('.')[0]; 

                html += `
                <div class="list-item-card" style="flex-direction:column; gap:5px; align-items:flex-start;">
                    <div style="display:flex; justify-content:space-between; width:100%; font-size:12px; color:#888;">
                        <span>${timeStr}</span>
                        <button class="p-btn p-btn-sm" style="padding:2px 6px;" onclick="restoreVersion('${key}', '${v.value}')">回退至此</button>
                    </div>
                    <div style="font-size:13px; color:#374151; word-break:break-all; background:#f9fafb; padding:5px; border-radius:4px; width:100%;">
                        ${v.value}
                    </div>
                </div>`;
            });
            cont.innerHTML = html;
        } else {
            cont.innerHTML = '<div style="text-align:center; color:#999; padding:20px;">暂无历史版本</div>';
        }
    } catch(e) {
        cont.innerHTML = '<div style="text-align:center; color:red;">加载失败</div>';
    }
}

// 执行回退
function restoreVersion(key, value) {
    if(!confirm("确定要回退到这个版本吗？\n当前的进度将会被覆盖。")) return;
    
    // 填入输入框
    document.getElementById('key').value = key;
    document.getElementById('value').value = value;
    
    // 关闭模态框
    PureUI.modal.close('versionModal');
    
    // 执行保存 (这会作为一次新的 manual save，生成新的历史记录，这是符合逻辑的)
    doAction('update');
}
        function renderGrid(data, container, keys) {
            let html = '<div class="bookshelf-grid">';
            keys.forEach(k => {
                const v = data[k];
                const parts = k.split('/');
                const title = parts[parts.length - 1];
                const bg = stringToColor(title);
                const isLink = v.startsWith('http') || v.startsWith('epub:');
                const clickAction = isLink ? `window.open('/read?url=${encodeURIComponent(v)}&key=${encodeURIComponent(k)}', '_blank')` : `PureUI.copy('${v}')`;
                
                html += `
                <div class="book-card" onclick="${clickAction}">
                    <div class="book-cover" style="background:${bg}">
                        <div class="book-title-card">${title.toUpperCase()}</div>
                    </div>
                    <div class="book-info-row">
                        <span>${title}</span>
                        <button class="p-btn p-btn-sm" style="padding:2px;" onclick="event.stopPropagation(); openAddToListModal('${k}', '${title}')" title="加入书单">🔖</button>
                        <button class="p-btn p-btn-sm" style="padding:2px;" onclick="event.stopPropagation(); openTagModal('${k}')" title="管理标签">🏷️</button>
                    </div>
                </div>`;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        // 标签/搜索/上传 功能
        function openTagModal(key) {
            document.getElementById('tagEditKey').value = key;
            const tags = globalTags[key] || [];
            document.getElementById('tagEditInput').value = tags.join(', ');
            PureUI.modal.open('tagModal');
            setTimeout(()=>document.getElementById('tagEditInput').focus(), 100);
        }
        async function saveTags() {
            const key = document.getElementById('tagEditKey').value;
            const tags = document.getElementById('tagEditInput').value.split(/[,，]/).map(t=>t.trim()).filter(t=>t);
            try {
                const res = await fetch(`${API_URL}/api/tags/update`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key, tags }) });
                if ((await res.json()).status === 'success') {
                    showMsg("🏷️ 标签已更新", "success");
                    if (tags.length > 0) globalTags[key] = tags; else delete globalTags[key];
                    renderFilterBar(); renderTable(currentData);
                    PureUI.modal.close('tagModal');
                }
            } catch(e) { showMsg("保存失败", "error"); }
        }

        function openSearchModal() { PureUI.modal.open('searchModal'); setTimeout(()=>document.getElementById('onlineSearchInput').focus(), 100); }
        async function doOnlineSearch() {
            const k = document.getElementById('onlineSearchInput').value.trim();
            if(!k) return;
            
            PureUI.loading.show('🔍 全网搜索中...');
            const div = document.getElementById('searchResults');
            div.innerHTML = '<div style="text-align:center; padding:40px; color:#666;">Trying hard to search...<br>🔍 全网聚合搜索中...</div>';
            
            try {
                const res = await fetch(`${API_URL}/api/search_novel`, { 
                    method:'POST', 
                    headers:{'Content-Type':'application/json'}, 
                    body:JSON.stringify({keyword:k})
                });
                const d = await res.json();
                
                if(d.data && d.data.length > 0) {
                    // index.html -> doOnlineSearch 函数内部

                    div.innerHTML = d.data.map(i => {
                        // 1. 确定标签颜色
                        let tagClass = 'tag-360';
                        if (i.source.includes('Baidu')) tagClass = 'tag-baidu';
                        else if (i.source.includes('Bing')) tagClass = 'tag-bing';
                        else if (i.source.includes('书香') || i.source.includes('笔趣') || i.source.includes('Direct')) tagClass = 'tag-direct';

                        // 2. [新增] 处理作者显示 (如果没有描述，就不显示)
                        // 后端插件返回格式为: description: "作者: 辰东"
                        const authorHtml = i.description ? `<span class="res-author">${i.description}</span>` : '';

                        // 3. 构建 HTML
                        return `
                        <div class="result-item" onclick="selectResult('${i.suggested_key}', '${i.url}')">
                            <div class="res-left">
                                <div class="res-title">
                                    ${i.title}
                                    ${authorHtml} <!-- 这里插入作者 -->
                                </div>
                                <div class="res-meta">
                                    <span class="source-tag ${tagClass}">${i.source || 'Unknown'}</span>
                                    <span class="res-url">${i.url}</span>
                                </div>
                            </div>
                            <div class="res-action">
                                解析并阅读 →
                            </div>
                        </div>`;
                    }).join('');
                } else {
                    div.innerHTML = '<div style="text-align:center; padding:40px; color:#999;">未找到相关结果，请尝试更换关键词</div>';
                }
            } catch(e) {
                div.innerHTML = '<div style="text-align:center; padding:40px; color:red;">搜索服务连接失败</div>';
            } finally {
                PureUI.loading.hide();
            }
        }
        async function loadBooks() {
        // 🔥 显示骨架屏
        const grid = document.getElementById('bookshelfGrid');
        const table = document.getElementById('tableContainer');
        
        if (grid && currentView === 'grid') {
            grid.innerHTML = Array(8).fill(0).map(() => '<div class="skeleton-card"></div>').join('');
        }
        if (table && currentView === 'list') {
            table.innerHTML = Array(5).fill(0).map(() => '<div class="skeleton-list-item"></div>').join('');
        }
        
        // 1. 先异步拉取红点数据
        try {
            const res = await fetch('/api/updates/all_red_dots');
            const json = await res.json();
            if (json.status === 'success') {
                redDotsSet = new Set(json.data);
            }
        } catch(e) {}

        // 2. 默认展示历史列表（最近 -> 最远）
        let historyKeys = [];
        let historyList = [];
        try {
            const hisRes = await fetch('/api/history/list');
            const hisJson = await hisRes.json();
            const list = Array.isArray(hisJson.data) ? hisJson.data : [];
            list.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
            historyList = list;

            const seen = new Set();
            list.forEach(item => {
                if (!item || !item.key) return;
                if (seen.has(item.key)) return;
                seen.add(item.key);
                historyKeys.push(item.key);
            });
        } catch (e) {}

        // 拉取完整数据，再按历史筛选
        const res = await fetch('/list', { method: 'POST' });
        const fullJson = await res.json();
        const fullData = fullJson && fullJson.data ? fullJson.data : {};
        fullDataCache = fullData;

        if (historyKeys.length > 0) {
            homeMode = 'history';
            historyOrder = historyKeys;

            const filtered = {};
            historyKeys.forEach(k => {
                if (fullData[k]) filtered[k] = fullData[k];
            });

            currentData = filtered;
            renderTable(filtered);
            return;
        }

        // 没有历史记录：只渲染“上一次阅读”
        try {
            const lastRes = await fetch('/api/last_read');
            const lastJson = await lastRes.json();
            if (lastJson && lastJson.key && fullData[lastJson.key]) {
                homeMode = 'books';
                const single = { [lastJson.key]: fullData[lastJson.key] };
                currentData = single;
                renderTable(single);
                return;
            }
        } catch (e) {}

        // 兜底：渲染完整书架
        homeMode = 'books';
        currentBooks = Object.entries(fullData).map(([k, v]) => ({ key: k, val: v }));
        renderBookshelf(currentBooks);
        renderTable(fullData);
    }
        async function downloadBook(key, url, title) {
    // 1. 简单的权限检查 (可选，提升体验)
    // 假设 api/me 返回了 role，如果没有 role 字段，说明还没刷新或者后端没传
    // 这里直接发请求，让后端判断权限更安全
    
    if(!confirm(`☁️ 离线下载确认\n\n即将开始下载《${title}》的全部章节。\n这可能需要 1-3 分钟，期间请勿频繁重启服务器。\n\n确定要开始吗？`)) {
        return;
    }

    try {
        showMsg("🚀 正在提交离线任务...", "info");
        
        const res = await fetch('/api/pro/download_book', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ key: key, url: url }) // 发送当前进度的 URL
        });
        
        const data = await res.json();
        
        if (data.status === 'success') {
            showMsg(data.msg, "success");
        } else {
            // 如果是权限不足 (403)，提示升级
            showMsg("❌ " + (data.message || "请求失败"), "error");
        }
    } catch (e) {
        showMsg("网络错误", "error");
    }
}
// 存储更新状态
let updatesCache = {};

// 1. 页面加载时获取更新状态
function fetchUpdates() {
    // 依然加时间戳防止 304 缓存
    fetch('/api/updates/status')
            .then(res => res.json())
            .then(data => {
                console.log("更新状态已获取 (全量):", data);
                
                // 调试：打印数据来源
                for (let k in data) {
                    if (data[k].unread_count > 0) {
                        console.log(`[书本 ${k}] 未读: ${data[k].unread_count}, 数据源: ${data[k].debug_source}`);
                    }
                }

                updatesCache = data;
                if(currentData) renderTable(currentData);
                renderUpdates();
            });
}
// 当页面从后台切回来，或者标签页被重新激活时触发
document.addEventListener("visibilitychange", function() {
    if (document.visibilityState === 'visible') {
        console.log("👀 页面重新可见，正在刷新数据...");
        
        // 1. 刷新列表 (以防 key 变了)
        // doAction('list'); // 可选：如果你想刷新整个列表，但这可能导致闪烁
        
        // 2. 刷新更新状态
        fetchUpdates();
    }
});
// 当页面从 BFCache (往复缓存) 中恢复时触发
window.addEventListener('pageshow', function(event) {
    // event.persisted 为 true 表示是从缓存恢复的
    // 但为了保险，我们无论是否缓存都刷一次
    console.log("🔄 页面显示 (pageshow)，强制刷新状态...");
    fetchUpdates();
});
// 3. [新增] 针对 Safari/移动端的 pageshow 事件 (解决后退不刷新问题)
window.addEventListener('pageshow', function(event) {
    if (event.persisted) {
        console.log("🔄 从缓存恢复页面，强制刷新状态...");
        fetchUpdates();
    }
});
// 记得在 renderTable 的最后调用一次 renderUpdates();

// 2. 渲染更新状态 (小红点)
// 在 index.html 的 script 标签中
// 在书架页增加一个入口按钮，仅在桌面模式显示
// --- 桌面端交互逻辑 ---

// 1. 初始化检查：如果是桌面端，显示设置按钮
if (window.electronAPI && window.electronAPI.isDesktop) {
    document.getElementById('desktopSettingsBtn').style.display = 'inline-flex';
}

// 2. 打开设置弹窗并加载当前配置
async function openDesktopSettings() {
    if (!window.electronAPI) return;
    
    // 从 Electron 获取当前快捷键
    const current = await window.electronAPI.getShortcuts();
    document.getElementById('bossKeyInput').value = current.bossKey;
    document.getElementById('ttsKeyInput').value = current.stopTtsKey;
    
    PureUI.modal.open('desktopSettingsModal');
}

// 3. 自动录入快捷键的逻辑
function bindKeyRecorder(inputId) {
    const el = document.getElementById(inputId);
    el.addEventListener('keydown', (e) => {
        e.preventDefault(); // 阻止默认行为（如刷新、搜索）
        e.stopPropagation();

        const modifiers = [];
        if (e.ctrlKey) modifiers.push('Ctrl');
        if (e.shiftKey) modifiers.push('Shift');
        if (e.altKey) modifiers.push('Alt');
        if (e.metaKey) modifiers.push('Super'); // Win/Command 键

        // 捕捉主要按键
        const key = e.key.toUpperCase();
        
        // 过滤掉单纯的修饰键本身
        if (['CONTROL', 'SHIFT', 'ALT', 'META'].includes(key)) return;

        // 规范化 Key 名称 (Electron 友好格式)
        let finalKey = key;
        if (key === ' ') finalKey = 'Space';
        if (key === 'ARROWUP') finalKey = 'Up';
        if (key === 'ARROWDOWN') finalKey = 'Down';
        if (key === 'ARROWLEFT') finalKey = 'Left';
        if (key === 'ARROWRIGHT') finalKey = 'Right';

        // 组合成字符串
        if (modifiers.length > 0) {
            el.value = modifiers.join('+') + '+' + finalKey;
        } else {
            el.value = finalKey;
        }
    });
}

// 为两个输入框绑定录入器
bindKeyRecorder('bossKeyInput');
bindKeyRecorder('ttsKeyInput');

// 4. 保存设置到 Electron
function saveDesktopSettings() {
    const newSettings = {
        bossKey: document.getElementById('bossKeyInput').value,
        stopTtsKey: document.getElementById('ttsKeyInput').value
    };

    if (window.electronAPI) {
        window.electronAPI.updateShortcuts(newSettings);
        showMsg("✅ 客户端配置已更新并生效", "success");
        PureUI.modal.close('desktopSettingsModal');
    }
}
function renderUpdates() {
    Object.keys(updatesCache).forEach(key => {
        const info = updatesCache[key];
        const btn = document.getElementById(`upd-${key}`);
        
        if (btn && info.unread_count > 0) {
            // 有更新：显示红色数字
            // 如果 unread_count 很多（比如 >99），显示 99+
            const countDisplay = info.unread_count > 99 ? '99+' : `+${info.unread_count}`;
            
            btn.innerHTML = `<span style="font-weight:bold; font-size:12px;">${countDisplay}</span>`;
            btn.style.color = "#ef4444"; // 红色
            btn.style.borderColor = "#ef4444";
            btn.style.background = "#fef2f2";
            btn.title = `最新：${info.latest_title}\n(${info.status_text})`;
        } else if (btn) {
            // 没更新或已读完：恢复默认
            btn.innerHTML = "🔄";
            btn.style.color = ""; 
            btn.style.borderColor = "";
            btn.style.background = "";
            btn.title = "检查更新";
        }
    });
}

// 3. 手动检查更新函数 (异步轮询版)
async function checkUpdate(key, url) {
    const btn = document.getElementById(`upd-${key}`);
    if (!btn) return;
    
    // 保存原始HTML以便恢复
    if (!btn.hasAttribute('data-original-html')) {
        btn.setAttribute('data-original-html', btn.innerHTML);
    }
    const originalHtml = btn.getAttribute('data-original-html');
    
    // 视觉反馈
    btn.innerHTML = `<span style="display:inline-block;animation:spin 1s linear infinite">⏳</span>`; 
    btn.disabled = true;

    try {
        const res = await fetch('/api/check_update', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ key: key, url: url })
        });
        const json = await res.json();
        
        if (json.status === 'pending') {
            await pollUpdateTask(json.task_id, key, originalHtml);
        } else {
            handleUpdateSuccess(json, key, originalHtml);
        }
    } catch (e) {
        console.error(e);
        btn.innerHTML = originalHtml;
        btn.disabled = false;
        showMsg("请求失败", "error");
    }
}

async function pollUpdateTask(taskId, key, originalHtml) {
    const btn = document.getElementById(`upd-${key}`);
    let attempts = 0;
    const maxAttempts = 60; // 60秒超时

    const poll = async () => {
        if (attempts >= maxAttempts) {
             showMsg("更新请求超时", "error");
             if(btn) { btn.innerHTML = originalHtml; btn.disabled = false; }
             return;
        }

        try {
            const res = await fetch(`/api/task_status/${taskId}`);
            const t = await res.json();
            
            if (t.status === 'completed') {
                try {
                    handleUpdateSuccess(t.result, key, originalHtml);
                } catch (err) {
                    console.error("Render update error:", err);
                    showMsg("结果渲染出错", "error");
                    if(btn) { btn.innerHTML = originalHtml; btn.disabled = false; }
                }
                return;
            } else if (t.status === 'failed') {
                showMsg("更新失败: " + t.error, "error");
                if(btn) { btn.innerHTML = originalHtml; btn.disabled = false; }
                return;
            } else if (t.status === 'not_found') {
                showMsg("任务已丢失", "error");
                if(btn) { btn.innerHTML = originalHtml; btn.disabled = false; }
                return;
            } else {
                attempts++;
                setTimeout(poll, 1000);
            }
        } catch(e) {
            console.error(e);
            attempts++;
            setTimeout(poll, 1000);
        }
    };
    poll();
}

async function handleUpdateSuccess(d_raw, key, originalHtml) {
    const btn = document.getElementById(`upd-${key}`);
    // d_raw 是 worker 返回的 {status, data, msg}
    
    if (d_raw.status === 'success') {
        const d = d_raw.data;
        
        // 1. 更新全局缓存
        updatesCache[key] = d;

        // 2. 提示用户
        let tip = `更新完成：${d.status_text}`;
        if (d.unread_count > 0) tip += ` (+${d.unread_count})`;
        showMsg(tip, "success");

        // 3. [核心] 重绘列表
        await doAction('find'); 
        
        // 4. 单独刷新按钮状态
        setTimeout(() => renderUpdates(), 50);
    } else {
        showMsg("未检测到更新: " + (d_raw.msg || "暂无"), "info");
        if(btn) { btn.innerHTML = originalHtml; btn.disabled = false; }
    }
}
// 记得在 renderTable 的最后调用一次 renderUpdates()，防止翻页/搜索后红点消失
// 在 renderTable 函数末尾加一行: renderUpdates();
        // === 替换 index.html 中的 selectResult 函数 ===
        async function selectResult(k, v) {
            // 1. 填入 Key 和 Value
            document.getElementById('key').value = k;
            document.getElementById('value').value = v;
            
            // 2. 关闭模态框
            PureUI.modal.close('searchModal'); 
            
            // 3. 提示用户 - 相信自动识别功能
            showMsg(`✅ 已填入链接，请点击添加（将自动识别目录或章节）`, 'success');
        }

        async function handleDrop(e) {
            document.getElementById('value').classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file && file.name.toLowerCase().endsWith('.epub')) {
                const fd = new FormData(); fd.append('file', file);
                const vIn = document.getElementById('value');
                vIn.value = "上传中...";
                const res = await fetch(`${API_URL}/api/upload_epub`, { method:'POST', body:fd });
                const r = await res.json();
                if(r.status==='success') { showMsg('上传成功', 'success'); document.getElementById('key').value=r.key; vIn.value=r.value; doAction('insert'); }
                else { showMsg('失败: '+r.message, 'error'); vIn.value=''; }
            } else showMsg("仅支持 .epub", "error");
        }

        // 洞察 (图表 + Tab)
        function openInsight() {
            PureUI.modal.open('insightModal');
            switchInsightTab('24h', document.querySelector('.insight-tab')); 
            fetch(`${API_URL}/api/analyze_stats`).then(r=>r.json()).then(res => {
                if (res.status === 'success') {
                    insightData = res;
                    window.statsData = res; // 保存到全局供主题切换时使用
                    renderHeatmap(res.summary.all.heatmap);
                    renderChart(res.summary.trend);
                    switchInsightTab('24h', document.querySelector('.insight-tab.active')); 
                }
            });
        }
        function switchInsightTab(p, btn) {
            document.querySelectorAll('.insight-tab').forEach(b => b.classList.remove('active'));
            if(btn) btn.classList.add('active');
            if (insightData && insightData.summary[p]) {
                const d = insightData.summary[p];
                document.getElementById('s-time').innerText = d.time;
                document.getElementById('s-words').innerText = d.words > 10000 ? (d.words/10000).toFixed(1) + '万' : d.words;
                document.getElementById('s-chapters').innerText = d.chapters;
                document.getElementById('s-books').innerText = d.books;
            }
        }
        let heatmapChart = null;
        
        function renderHeatmap(data) {
            const container = document.getElementById('heatmapChart');
            if (!container) return;
            
            // 初始化 ECharts 实例（复用已存在的实例）
            if (!heatmapChart) {
                heatmapChart = echarts.init(container);
            }
            
            // 转换数据格式为 ECharts 需要的格式 [["2024-01-01", 120], ...]
            const chartData = data.map(d => [d.date, d.count]);
            
            // 计算起止日期
            const today = new Date();
            const sixMonthsAgo = new Date();
            sixMonthsAgo.setMonth(today.getMonth() - 6);
            
            const startDate = sixMonthsAgo.toISOString().split('T')[0];
            const endDate = today.toISOString().split('T')[0];
            
            // 检测暗色模式
            const isDark = document.body.classList.contains('dark-mode') || 
                          window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            const option = {
                tooltip: {
                    position: 'top',
                    formatter: function(params) {
                        return params.value[0] + ': ' + params.value[1] + '分钟';
                    }
                },
                visualMap: {
                    min: 0,
                    max: 150,
                    type: 'piecewise',
                    orient: 'horizontal',
                    left: 'center',
                    top: 0,
                    pieces: [
                        {min: 0, max: 0, color: isDark ? '#2d333b' : '#ebedf0'},
                        {min: 1, max: 30, color: '#9be9a8'},
                        {min: 31, max: 60, color: '#40c463'},
                        {min: 61, max: 120, color: '#30a14e'},
                        {min: 121, color: '#216e39'}
                    ],
                    text: ['多', '少'],
                    textStyle: {
                        color: '#888',
                        fontSize: 10
                    },
                    itemWidth: 10,
                    itemHeight: 10,
                    show: true
                },
                calendar: {
                    top: 35,
                    left: 20,
                    right: 20,
                    cellSize: ['auto', 12],
                    range: [startDate, endDate],
                    itemStyle: {
                        borderWidth: 3,
                        borderColor: isDark ? '#1a1d23' : '#fff'
                    },
                    splitLine: {
                        show: false
                    },
                    dayLabel: {
                        nameMap: ['日', '一', '二', '三', '四', '五', '六'],
                        fontSize: 10,
                        color: '#888'
                    },
                    monthLabel: {
                        fontSize: 10,
                        color: '#888'
                    },
                    yearLabel: {
                        show: false
                    }
                },
                series: [{
                    type: 'heatmap',
                    coordinateSystem: 'calendar',
                    data: chartData
                }]
            };
            
            heatmapChart.setOption(option, true);
        }
        
        // 响应式调整（只绑定一次）
        let resizeHandler = null;
        let themeHandler = null;
        
        if (!resizeHandler) {
            resizeHandler = function() {
                if (heatmapChart) heatmapChart.resize();
            };
            window.addEventListener('resize', resizeHandler);
        }
        
        // 监听暗色模式变化
        if (!themeHandler && window.matchMedia) {
            const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');
            themeHandler = function() {
                // 如果热力图已经渲染，重新渲染以更新颜色
                if (heatmapChart && window.statsData) {
                    renderHeatmap(window.statsData.summary.all.heatmap);
                }
            };
            darkModeQuery.addEventListener('change', themeHandler);
        }
        
        // 监听 dark-mode class 变化
        if (typeof MutationObserver !== 'undefined') {
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.attributeName === 'class') {
                        if (heatmapChart && window.statsData) {
                            renderHeatmap(window.statsData.summary.all.heatmap);
                        }
                    }
                });
            });
            observer.observe(document.body, { attributes: true });
        }
        function renderChart(trend) {
            if(chartInstance) chartInstance.destroy();
            chartInstance = new Chart(document.getElementById('trendChart'), {
                type: 'line',
                data: {
                    labels: trend.dates,
                    datasets: [{
                        label: '时长 (分钟)',
                        data: trend.times,
                        borderColor: '#4f46e5',
                        backgroundColor: 'rgba(79, 70, 229, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: { responsive: true, maintainAspectRatio: false, plugins: {legend:{display:false}}, scales:{x:{display:false}, y:{display:false}} }
            });
        }
        
        // ==========================================
        // 导出功能
        // ==========================================
        let exportTaskId = null;
        let exportPollInterval = null;
        let exportCurrentKey = null;
        let exportCurrentUrl = null;
        let exportStartTime = null;
        let exportLastUpdate = { time: 0, current: 0 };
        let exportUnfinishedTask = null;
        let exportIsPaused = false;
        
        function updateSpeedText(delay) {
            const delayNum = parseFloat(delay);
            let text;
            if (delayNum <= 0.3) {
                text = `极速 (${delayNum}秒/章)`;
            } else if (delayNum <= 0.8) {
                text = `中速 (${delayNum}秒/章)`;
            } else if (delayNum <= 1.5) {
                text = `慢速 (${delayNum}秒/章)`;
            } else {
                text = `安全模式 (${delayNum}秒/章)`;
            }
            document.getElementById('exportSpeedText').textContent = text;
            // 保存到 localStorage
            localStorage.setItem('exportDelay', delay);
        }
        
        async function togglePause() {
            if (!exportTaskId) return;
            
            const pauseBtn = document.getElementById('exportPauseBtn');
            
            try {
                if (exportIsPaused) {
                    // 恢复
                    const res = await fetch('/api/export/resume', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            task_id: exportTaskId, 
                            url: exportCurrentUrl,
                            delay: parseFloat(document.getElementById('exportDelaySlider').value)
                        })
                    });
                    
                    const json = await res.json();
                    if (json.success) {
                        exportIsPaused = false;
                        pauseBtn.textContent = '⏸ 暂停';
                        document.getElementById('exportStatusText').textContent = '正在恢复...';
                        pollExportStatus(); // 重新开始轮询
                    }
                } else {
                    // 暂停
                    const res = await fetch('/api/export/pause', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ task_id: exportTaskId })
                    });
                    
                    const json = await res.json();
                    if (json.success) {
                        exportIsPaused = true;
                        pauseBtn.textContent = '▶️ 继续';
                        document.getElementById('exportStatusText').textContent = '⏸️ 已暂停';
                        if (exportPollInterval) {
                            clearInterval(exportPollInterval);
                            exportPollInterval = null;
                        }
                    }
                }
            } catch (e) {
                console.error('暂停/恢复失败:', e);
                PureUI.toast('error', '操作失败：' + e.message);
            }
        }
        
        async function showExportModal(key, encodedUrl) {
            exportCurrentKey = key;
            exportCurrentUrl = decodeURIComponent(encodedUrl);
            exportStartTime = null;
            exportLastUpdate = { time: 0, current: 0 };
            exportUnfinishedTask = null;
            
            // 重置 Modal 状态
            document.getElementById('exportBookName').textContent = key;
            document.getElementById('exportProgressArea').style.display = 'none';
            document.getElementById('exportError').style.display = 'none';
            document.getElementById('exportStartBtn').disabled = false;
            document.getElementById('exportStartBtn').style.opacity = '1';
            document.getElementById('exportStartBtn').style.cursor = 'pointer';
            document.getElementById('exportStartBtn').textContent = '开始导出';
            document.getElementById('exportProgressBar').style.width = '0%';
            document.getElementById('exportCancelBtn').textContent = '取消';
            
            // 重置格式选择（默认 TXT）
            document.querySelector('input[name="exportFormat"][value="txt"]').checked = true;
            const labels = document.querySelectorAll('#exportModal label');
            labels.forEach(l => l.style.borderColor = '#e5e7eb');
            labels[0].style.borderColor = '#4f46e5';
            
            // 恢复保存的速度设置
            const savedDelay = localStorage.getItem('exportDelay') || '0.5';
            document.getElementById('exportDelaySlider').value = savedDelay;
            updateSpeedText(savedDelay);
            
            // 检查是否有未完成的任务
            try {
                const res = await fetch('/api/export/check_unfinished', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ book_name: key })
                });
                
                const json = await res.json();
                
                if (json.status === 'success' && json.has_unfinished) {
                    exportUnfinishedTask = json;
                    showResumePrompt(json.task);
                }
            } catch (e) {
                console.error('检查未完成任务失败:', e);
            }
            
            // 打开 Modal
            PureUI.modal.open('exportModal');
        }
        
        function showResumePrompt(task) {
            const progressArea = document.getElementById('exportProgressArea');
            progressArea.style.display = 'block';
            
            const percent = Math.round((task.current / task.total) * 100);
            document.getElementById('exportProgressBar').style.width = percent + '%';
            
            // 显示任务的延迟设置
            const taskDelay = task.delay || 0.5;
            document.getElementById('exportDelaySlider').value = taskDelay;
            updateSpeedText(taskDelay);
            
            document.getElementById('exportStatusText').textContent = '⏸️ 检测到未完成的导出任务';
            document.getElementById('exportProgressText').textContent = `已完成 ${task.current}/${task.total} (${percent}%)`;
            
            const startBtn = document.getElementById('exportStartBtn');
            startBtn.textContent = '继续导出';
            startBtn.style.background = '#059669';
            
            const cancelBtn = document.getElementById('exportCancelBtn');
            cancelBtn.textContent = '放弃并重新开始';
        }
        
        function selectExportFormat(format, labelElement) {
            document.querySelectorAll('#exportModal label').forEach(l => l.style.borderColor = '#e5e7eb');
            labelElement.style.borderColor = '#4f46e5';
            document.querySelector(`input[name="exportFormat"][value="${format}"]`).checked = true;
        }
        
        function cancelExport() {
            if (exportPollInterval) {
                clearInterval(exportPollInterval);
                exportPollInterval = null;
            }
            
            // 如果是在显示续传提示时点击"放弃"，清空未完成任务
            if (exportUnfinishedTask) {
                exportUnfinishedTask = null;
                // 重置 UI 回到新建状态
                document.getElementById('exportProgressArea').style.display = 'none';
                document.getElementById('exportStartBtn').textContent = '开始导出';
                document.getElementById('exportStartBtn').style.background = '#4f46e5';
                document.getElementById('exportCancelBtn').textContent = '取消';
                return; // 不关闭弹窗，让用户重新选择
            }
            
            PureUI.modal.close('exportModal');
        }
        
        function resetExport() {
            if (!confirm('确定要重新开始吗？当前进度将会丢失。')) return;
            
            // 停止轮询
            if (exportPollInterval) {
                clearInterval(exportPollInterval);
                exportPollInterval = null;
            }
            
            // 重置状态
            exportTaskId = null;
            exportStartTime = null;
            exportLastUpdate = { time: 0, current: 0 };
            
            // 重置 UI
            document.getElementById('exportProgressArea').style.display = 'none';
            document.getElementById('exportError').style.display = 'none';
            document.getElementById('exportStartBtn').disabled = false;
            document.getElementById('exportStartBtn').style.opacity = '1';
            document.getElementById('exportStartBtn').style.cursor = 'pointer';
            document.getElementById('exportStartBtn').textContent = '开始导出';
            document.getElementById('exportProgressBar').style.width = '0%';
            document.getElementById('exportCancelBtn').textContent = '取消';
            
            PureUI.toast.info('已重置，可以重新开始导出');
        }
        
        async function startExportTask() {
            const format = document.querySelector('input[name="exportFormat"]:checked').value;
            const startBtn = document.getElementById('exportStartBtn');
            const progressArea = document.getElementById('exportProgressArea');
            const errorDiv = document.getElementById('exportError');
            
            // 禁用按钮
            startBtn.disabled = true;
            startBtn.style.opacity = '0.5';
            startBtn.style.cursor = 'not-allowed';
            
            // 显示进度区域
            progressArea.style.display = 'block';
            errorDiv.style.display = 'none';
            
            // 判断是续传还是新建
            const isResume = exportUnfinishedTask && exportUnfinishedTask.has_unfinished;
            
            if (isResume) {
                document.getElementById('exportStatusText').textContent = '正在恢复导出...';
            } else {
                document.getElementById('exportStatusText').textContent = '正在启动导出...';
                document.getElementById('exportProgressText').textContent = '0/0';
            }
            
            try {
                const requestBody = {
                    key: exportCurrentKey,
                    book_name: exportCurrentKey,
                    format: format,
                    delay: parseFloat(document.getElementById('exportDelaySlider').value)  // 添加延迟参数
                };
                
                // 如果是续传，添加 resume_task_id
                if (isResume) {
                    requestBody.resume_task_id = exportUnfinishedTask.task_id;
                }
                
                // 启动导出任务
                const res = await fetch('/api/export/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                const json = await res.json();
                
                if (json.status === 'success') {
                    exportTaskId = json.task_id;
                    exportUnfinishedTask = null; // 清空未完成任务标记
                    pollExportStatus();
                } else {
                    throw new Error(json.msg || '启动失败');
                }
            } catch (e) {
                errorDiv.textContent = '❌ ' + e.message;
                errorDiv.style.display = 'block';
                startBtn.disabled = false;
                startBtn.style.opacity = '1';
                startBtn.style.cursor = 'pointer';
                if (!isResume) {
                    progressArea.style.display = 'none';
                }
            }
        }
        
        function pollExportStatus() {
            if (!exportTaskId) return;
            
            exportPollInterval = setInterval(async () => {
                try {
                    const res = await fetch(`/api/export/status?task_id=${exportTaskId}`);
                    const json = await res.json();
                    
                    if (json.status === 'success') {
                        const task = json.task;
                        const progress = task.total > 0 ? Math.round((task.current / task.total) * 100) : 0;
                        
                        // 更新进度条
                        document.getElementById('exportProgressBar').style.width = progress + '%';
                        
                        // 计算剩余时间
                        const currentTime = Date.now();
                        if (!exportStartTime) {
                            exportStartTime = currentTime;
                            exportLastUpdate = { time: currentTime, current: task.current };
                        }
                        
                        let timeInfo = `${task.current}/${task.total}`;
                        
                        // 如果已经抓取了至少 3 个章节，开始计算剩余时间
                        if (task.current > 3 && task.status === 'running') {
                            const elapsed = (currentTime - exportStartTime) / 1000; // 秒
                            const speed = task.current / elapsed; // 章节/秒
                            const remaining = task.total - task.current;
                            const remainingTime = remaining / speed; // 秒
                            
                            // 格式化剩余时间
                            if (remainingTime < 60) {
                                timeInfo += ` (剩余 ${Math.ceil(remainingTime)} 秒)`;
                            } else if (remainingTime < 3600) {
                                timeInfo += ` (剩余 ${Math.ceil(remainingTime / 60)} 分钟)`;
                            } else {
                                const hours = Math.floor(remainingTime / 3600);
                                const minutes = Math.ceil((remainingTime % 3600) / 60);
                                timeInfo += ` (剩余 ${hours} 小时 ${minutes} 分钟)`;
                            }
                            
                            // 显示速度
                            const speedText = speed >= 1 ? `${speed.toFixed(1)} 章/秒` : `${(60 / speed).toFixed(1)} 秒/章`;
                            document.getElementById('exportStatusText').textContent = `正在抓取 (${speedText})`;
                        }
                        
                        document.getElementById('exportProgressText').textContent = timeInfo;
                        
                        if (task.status === 'running') {
                            if (task.current <= 3) {
                                document.getElementById('exportStatusText').textContent = '正在抓取章节...';
                            }
                            // 显示暂停按钮
                            document.getElementById('exportPauseBtn').style.display = 'block';
                            document.getElementById('exportPauseBtn').textContent = '⏸ 暂停';
                            // 修改取消按钮为重新开始
                            const cancelBtn = document.getElementById('exportCancelBtn');
                            cancelBtn.textContent = '重新开始';
                            cancelBtn.onclick = resetExport;
                        } else if (task.status === 'paused') {
                            clearInterval(exportPollInterval);
                            exportPollInterval = null;
                            
                            document.getElementById('exportStatusText').textContent = '⏸️ 已暂停';
                            document.getElementById('exportPauseBtn').textContent = '▶️ 继续';
                            document.getElementById('exportCancelBtn').textContent = '取消';
                            document.getElementById('exportCancelBtn').onclick = cancelExport;
                        } else if (task.status === 'completed') {
                            clearInterval(exportPollInterval);
                            exportPollInterval = null;
                            
                            document.getElementById('exportStatusText').textContent = '✅ 导出完成！';
                            document.getElementById('exportPauseBtn').style.display = 'none';
                            document.getElementById('exportProgressText').textContent = '完成';
                            document.getElementById('exportProgressBar').style.width = '100%';
                            
                            // 恢复取消按钮
                            const cancelBtn = document.getElementById('exportCancelBtn');
                            cancelBtn.textContent = '关闭';
                            cancelBtn.onclick = cancelExport;
                            
                            // 自动下载
                            PureUI.toast.success('导出完成，正在下载...');
                            setTimeout(async () => {
                                try {
                                    const res = await fetch(`/api/export/download?task_id=${exportTaskId}`);
                                    const blob = await res.blob();
                                    const url = window.URL.createObjectURL(blob);
                                    const a = document.createElement('a');
                                    a.href = url;
                                    a.download = task.filename || '导出文件.txt';
                                    document.body.appendChild(a);
                                    a.click();
                                    document.body.removeChild(a);
                                    window.URL.revokeObjectURL(url);
                                    
                                    setTimeout(() => {
                                        PureUI.modal.close('exportModal');
                                    }, 500);
                                } catch (e) {
                                    console.error('下载失败:', e);
                                    PureUI.toast('error', '下载失败，请手动下载');
                                }
                            }, 500);
                        } else if (task.status === 'error') {
                            clearInterval(exportPollInterval);
                            exportPollInterval = null;
                            
                            const errorDiv = document.getElementById('exportError');
                            errorDiv.textContent = '❌ 导出失败：' + (task.error_msg || '未知错误');
                            errorDiv.style.display = 'block';
                            
                            // 允许重新开始
                            const startBtn = document.getElementById('exportStartBtn');
                            startBtn.disabled = false;
                            startBtn.style.opacity = '1';
                            startBtn.style.cursor = 'pointer';
                            startBtn.textContent = '重新开始';
                            
                            const cancelBtn = document.getElementById('exportCancelBtn');
                            cancelBtn.textContent = '取消';
                            cancelBtn.onclick = cancelExport;
                        }
                    }
                } catch (e) {
                    console.error('轮询失败:', e);
                }
            }, 1000); // 每秒轮询一次
        }
        
        // ==========================================
        // 导出历史记录
        // ==========================================
        async function openExportHistory() {
            try {
                const res = await fetch('/api/export/list');
                const json = await res.json();
                
                if (json.success) {
                    const list = document.getElementById('exportHistoryList');
                    
                    if (json.tasks.length === 0) {
                        list.innerHTML = '<div style="text-align:center; color:#999; padding:40px;">暂无导出记录</div>';
                    } else {
                        list.innerHTML = json.tasks.map(task => {
                            const statusIcon = task.status === 'completed' ? '✅' : '⏸️';
                            const statusText = task.status === 'completed' ? '已完成' : '已暂停';
                            const statusColor = task.status === 'completed' ? '#059669' : '#fb923c';
                            
                            const progress = task.total > 0 ? Math.round((task.current / task.total) * 100) : 0;
                            
                            return `
                                <div style="border:1px solid #e5e7eb; border-radius:8px; padding:15px; margin-bottom:10px;">
                                    <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:10px;">
                                        <div style="flex:1;">
                                            <div style="font-weight:500; color:#333; margin-bottom:5px;">${task.book_name}</div>
                                            <div style="font-size:12px; color:#999;">
                                                ${task.format.toUpperCase()} · ${task.current}/${task.total} 章 · ${progress}%
                                            </div>
                                        </div>
                                        <span style="font-size:12px; color:${statusColor}; padding:4px 8px; background:${statusColor}15; border-radius:4px;">
                                            ${statusIcon} ${statusText}
                                        </span>
                                    </div>
                                    
                                    ${task.status === 'completed' ? `
                                        <div style="display:flex; gap:8px;">
                                            <button onclick="window.location.href='/api/export/download?task_id=${task.task_id}'" 
                                                style="flex:1; padding:8px; border:1px solid #4f46e5; background:#fff; color:#4f46e5; border-radius:6px; cursor:pointer; font-size:13px;">
                                                📥 下载
                                            </button>
                                        </div>
                                    ` : `
                                        <div style="margin-top:10px; background:#f9fafb; padding:8px; border-radius:4px; font-size:12px; color:#666;">
                                            💡 在书架中找到该书，点击导出全书按钮可继续
                                        </div>
                                    `}
                                </div>
                            `;
                        }).join('');
                    }
                    
                    PureUI.modal.open('exportHistoryModal');
                } else {
                    PureUI.toast('error', json.msg || '获取导出历史失败');
                }
            } catch (e) {
                console.error('获取导出历史失败:', e);
                PureUI.toast('error', '获取导出历史失败：' + e.message);
            }
        }
        
        // ==========================================
        // 下载管理功能（Pro 专属）
        // ==========================================
        async function openDownloadsManager() {
            try {
                const res = await fetch('/api/pro/list_downloads');
                const json = await res.json();
                
                if (json.success) {
                    const list = document.getElementById('downloadsList');
                    
                    if (json.files.length === 0) {
                        list.innerHTML = '<div style="text-align:center; color:#999; padding:40px;">暂无下载文件</div>';
                    } else {
                        list.innerHTML = json.files.map(file => {
                            const sizeInMB = (file.size / (1024 * 1024)).toFixed(2);
                            const date = new Date(file.modified * 1000).toLocaleString('zh-CN');
                            const ext = file.filename.split('.').pop().toUpperCase();
                            const icon = ext === 'EPUB' ? '' : '';
                            
                            return `
                                <div style="border:1px solid #e5e7eb; border-radius:8px; padding:15px; margin-bottom:10px;">
                                    <div style="display:flex; align-items:start; gap:12px;">
                                        <div style="font-size:32px;">${icon}</div>
                                        <div style="flex:1;">
                                            <div style="font-weight:500; color:#333; margin-bottom:5px; word-break:break-all;">${file.filename}</div>
                                            <div style="font-size:12px; color:#999;">
                                                ${ext}  ${sizeInMB} MB  ${date}
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div style="display:flex; gap:8px; margin-top:12px;">
                                        <button onclick="downloadLocalFile('${file.filename}')" 
                                            style="flex:1; padding:8px; border:1px solid #4f46e5; background:#fff; color:#4f46e5; border-radius:6px; cursor:pointer; font-size:13px;">
                                             下载到本地
                                        </button>
                                        <button onclick="deleteLocalFile('${file.filename}')" 
                                            style="padding:8px 16px; border:1px solid #ef4444; background:#fff; color:#ef4444; border-radius:6px; cursor:pointer; font-size:13px;">
                                            
                                        </button>
                                    </div>
                                </div>
                            `;
                        }).join('');
                    }
                    
                    PureUI.modal.open('downloadsManagerModal');
                } else {
                    PureUI.toast('error', json.msg || '获取文件列表失败');
                }
            } catch (e) {
                console.error('获取下载列表失败:', e);
                PureUI.toast('error', '获取下载列表失败：' + e.message);
            }
        }
        
        async function downloadLocalFile(filename) {
            try {
                const res = await fetch(`/api/pro/download_file?filename=${encodeURIComponent(filename)}&t=${Date.now()}`, {
                    cache: 'no-store',
                    headers: { 'Cache-Control': 'no-cache' }
                });
                if (!res.ok) {
                    let msg = `下载失败 (${res.status})`;
                    try {
                        const err = await res.json();
                        msg = err.message || err.msg || msg;
                    } catch (e) {}
                    throw new Error(msg);
                }
                const blob = await res.blob();
                if (!blob || blob.size === 0) {
                    throw new Error('空文件');
                }
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                PureUI.toast('success', '开始下载');
            } catch (e) {
                console.error('下载失败:', e);
                PureUI.toast('error', '下载失败：' + e.message);
            }
        }
        
        async function deleteLocalFile(filename) {
            if (!confirm(`确定要删除 "${filename}" 吗？`)) return;
            
            try {
                const res = await fetch('/api/pro/delete_file', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename })
                });
                
                const json = await res.json();
                
                if (json.success) {
                    PureUI.toast('success', '删除成功');
                    // 重新加载列表
                    openDownloadsManager();
                } else {
                    PureUI.toast('error', json.msg || '删除失败');
                }
            } catch (e) {
                console.error('删除失败:', e);
                PureUI.toast('error', '删除失败：' + e.message);
            }
        }
    </script>
</body>
</html>
